<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>GrpahQL DataLoader를 이용한 성능 최적화 | y0c</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="https://y0c.github.io/2019/11/24/graphql-query-optimize-with-dataloader/">
<meta name="description" content="이번 포스팅에서는 GraphQL 에서 N+1 문제를 해결하기 위한 솔루션인 DataLoader에 대한 소개와 GraphQL 에 DataLoader를 어떤식으로 적용해야되는지를 정리해보려고 한다. N+1 문제N+1 문제는 ORM을 사용할때 주로…">
<meta property="og:type" content="article">
<meta property="og:title" content="GrpahQL DataLoader를 이용한 성능 최적화">
<meta property="og:url" content="https://y0c.github.io/2019/11/24/graphql-query-optimize-with-dataloader/">
<meta property="og:site_name" content="y0c">
<meta property="og:description" content="이번 포스팅에서는 GraphQL 에서 N+1 문제를 해결하기 위한 솔루션인 DataLoader에 대한 소개와 GraphQL 에 DataLoader를 어떤식으로 적용해야되는지를 정리해보려고 한다. N+1 문제N+1 문제는 ORM을 사용할때 주로…">
<meta property="og:image" content="https://y0c.github.io/images/">
<meta property="og:updated_time" content="2019-11-24T14:39:33.303Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GrpahQL DataLoader를 이용한 성능 최적화">
<meta name="twitter:description" content="이번 포스팅에서는 GraphQL 에서 N+1 문제를 해결하기 위한 솔루션인 DataLoader에 대한 소개와 GraphQL 에 DataLoader를 어떤식으로 적용해야되는지를 정리해보려고 한다. N+1 문제N+1 문제는 ORM을 사용할때 주로…">
<meta name="twitter:image" content="https://y0c.github.io/images/"><meta property="article:author" content="hosung"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2019-11-24 19:23:15"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="hosung"><link rel="icon" href="/images/logo.png"><link rel="alternate" href="/feed.xml" type="application/atom+xml" title="y0c"><script>(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-112029921-1', 'auto');
ga('send', 'pageview');</script></head><body itemscope="" itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.png" alt="y0c"><span class="menu__item__link--brand__label">y0c</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope="" itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope="" itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">GrpahQL DataLoader를 이용한 성능 최적화</h1><div class="article__meta"><time class="article__meta__time" datetime="2019-11-24T10:23:15.000Z" itemprop="datePublished">2019-11-24 19:23:15</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/graphql/">graphql</a></div></div><div class="article__contents"><img src="/images/"><p>이번 포스팅에서는 GraphQL 에서 N+1 문제를 해결하기 위한 솔루션인 DataLoader에 대한 소개와 GraphQL 에 DataLoader를 어떤식으로 적용해야되는지를 정리해보려고 한다.</p>
<h2 id="N-1-문제"><a href="#N-1-문제" class="headerlink" title="N+1 문제"></a>N+1 문제</h2><p>N+1 문제는 ORM을 사용할때 주로 발생하는 성능 문제이다.</p>
<p><code>Post</code> 엔티티와 <code>Comment</code> 엔티티가 있다고 가정해보자. 이 엔티티간의 관계는 <code>1:N</code>으로 정의할 수 있다. Post 목록과 post에 해당하는 comments를 조회하려 한다면 comment entity가 lazy loading되면서 N(각각의 comments 조회) + 1(post 조회) 만큼 쿼리가 실행되서 N+1 문제라고 부른다.</p>
<p>해결방법으로는 lazy loading을 하는 대신 미리 JOIN 연산을 통해 fetch하는 방법을 생각할 수 있다. 여기에 대한 방법은 ORM 마다 차이가 있을 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeORM example</span></span><br><span class="line"><span class="comment">// lazy</span></span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> Post.find(&#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> comments = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(posts.map(<span class="keyword">async</span> (p) =&gt; &#123;</span><br><span class="line">  <span class="comment">// TypeORM에서 lazy relation 경우 p.comments 는 promise array 이다.</span></span><br><span class="line">  <span class="keyword">const</span> comments = <span class="keyword">await</span> p.comments</span><br><span class="line">  <span class="keyword">return</span> comments</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// eager</span></span><br><span class="line"><span class="keyword">const</span> posts = <span class="keyword">await</span> Post.find(&#123; relations: [ <span class="string">'comments'</span> ] &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="GraphQL-에서의-N-1-문제"><a href="#GraphQL-에서의-N-1-문제" class="headerlink" title="GraphQL 에서의 N+1 문제"></a>GraphQL 에서의 N+1 문제</h2><p>GrpahQL에서 발생하는 N+1문제도 위와 비슷하다.<br>위에서의 엔티티관계를 GraphQL SDL로 작성하면 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Post &#123;</span><br><span class="line">  id: Int!</span><br><span class="line">  title: String!</span><br><span class="line">  content: String!</span><br><span class="line">  comments: [Comment!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Comment &#123;</span><br><span class="line">  id: Int!</span><br><span class="line">  content: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  posts: [Post!]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>post 목록과 comments 를 가져오는 query를 작성해보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  posts &#123;  # posts query (1)</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    content</span><br><span class="line">    comments &#123; # comments query (N) -&gt; Post 개수만큼</span><br><span class="line">      id</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 comments 부분에서 성능문제가 발생하게 된다.<br>GraphQL 에서 resolver를 구성하는 전략은 여러가지가 있겠지만 보통 다른 type과 관계가 있는 경우 resolver를 분리해서 구현하는 경우가 많기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolver = &#123;</span><br><span class="line">  Query: &#123;</span><br><span class="line">    posts: <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> Post.find(&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Post: &#123;</span><br><span class="line">    <span class="comment">// posts query를 호출할경우 post 개수(N) 만큼 호출된다.</span></span><br><span class="line">    comments: <span class="keyword">async</span> (root) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> Comment.find(&#123; <span class="attr">where</span>: &#123; <span class="attr">postId</span>: root.id &#125; &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>물론 아래와 같이 posts resolver에서 data를 join 해서 fetch후에 return 한다면 N+1 문제는 발생하지 않을 수 있다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resovler = &#123;</span><br><span class="line">  Query: &#123;</span><br><span class="line">    posts: <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> posts = <span class="keyword">await</span> Post.find(&#123; relations: [<span class="string">'comments'</span>] &#125;)</span><br><span class="line">      <span class="keyword">return</span> posts</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">query &#123;</span></span><br><span class="line"><span class="comment">  posts &#123;</span></span><br><span class="line"><span class="comment">    id</span></span><br><span class="line"><span class="comment">    title</span></span><br><span class="line"><span class="comment">    content</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>하지만 위와 같이 resolver를 구현한다면 query에서 comments field 를 요청하지 않아도 join해서 fetch해서 data를 가져오게된다. client에서 받는 데이터는 over fetching이 일어나지 않지만 실제 데이터를 load하는 곳에서는 over fetching이 일어나고 있는 것이다.</p>
<h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>DataLoader는 data fetch 할때 나타나는 N+1 문제를 batching을 통해 1+1로 변환해주는 library이다.<br>주로 GrpahQL 에서 많이 사용되지만 GrpahQL에 어떤 의존성을 가지고 있지는 않다.</p>
<h2 id="Batching"><a href="#Batching" class="headerlink" title="Batching"></a>Batching</h2><p>DataLoader는 javascript의 event-loop 을 이용한다. 주요기능인 batching은 event-loop 중 하나의 tick에서 실행된 data fetch에 대한 요청을 하나의 요청으로 모아서 실행하고 그 결과를 다시 알맞게 분배하는 역할을 한다.</p>
<p>아래 간단한 예제를 보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DataLoader = <span class="built_in">require</span>(<span class="string">'dataloader'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fake data</span></span><br><span class="line"><span class="keyword">const</span> posts = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">'test1'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">'test2'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">'test3'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">title</span>: <span class="string">'test4'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">title</span>: <span class="string">'test5'</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// fake db operation</span></span><br><span class="line"><span class="keyword">const</span> findAllPosts = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(posts)</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// batchLoadFn 의 결과는 promise여야 한다.</span></span><br><span class="line"><span class="keyword">const</span> batchLoadFn = <span class="keyword">async</span> (keys) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> results = <span class="keyword">await</span> findAllPosts()</span><br><span class="line">  <span class="built_in">console</span>.log(keys)</span><br><span class="line">  <span class="comment">// db 에서 받아온 결과를 요청온 key에 mapping</span></span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">k</span> =&gt;</span> results.find(<span class="function"><span class="params">p</span> =&gt;</span> p.id === k))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> postLoader = <span class="keyword">new</span> DataLoader(batchLoadFn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// tick 1</span></span><br><span class="line">postLoader.load(<span class="number">1</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line">postLoader.load(<span class="number">2</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tick 2</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  postLoader.load(<span class="number">3</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line">  postLoader.load(<span class="number">4</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>DataLoader의 constructor는 batch요청을 어떻게 처리할지에 대한 <code>batchLoadFn</code> 을 인자로 받는다.<br>이 <code>batchLoadFn</code>의 역할은 하나의 tick에서 들어온 <code>key</code>들에 대한 요청을 모아서 하나의 요청을 만들어 DB에 query하고 그 결과를 요청온 key에 맞게 mapping 한다.<br>(이 예제에서는 편의상 memory상에 data를 활용하였다.)</p>
<p><code>setTimeout</code>은 event-loop 상에 하나의 tick 에서 실행되지 않고 다음으로 실행을 미루게 된다.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1, 2]</span><br><span class="line">[3, 4]</span><br><span class="line"></span><br><span class="line">&#123; id: 1 ... &#125;</span><br><span class="line">&#123; id: 2 ... &#125;</span><br><span class="line">&#123; id: 3 ... &#125;</span><br><span class="line">&#123; id: 4 ... &#125;</span><br></pre></td></tr></table></figure>
<p>tick 이 2번 발생했기 때문에 load를 4번 호출하여도 실제요청은 2번만 실행되는걸 확인할 수 있다.</p>
<p>전체적인 동작을 다시 정리하면 <code>load</code> 를 개별적으로 호출하지만 실행되는 tick 별로 grouping해서 batch 요청을 하게되고 그 결과를 다시 개별적으로 나눠서 반환하게 된다.<br>즉, 데이터를 lazy loading하면서 성능저하의 문제를 해결할 수 있다.</p>
<h2 id="GraphQL에-DataLoader-적용"><a href="#GraphQL에-DataLoader-적용" class="headerlink" title="GraphQL에 DataLoader 적용"></a>GraphQL에 DataLoader 적용</h2><p>아까 문제가 되었던 resolver에 DataLoader를 적용해보자.<br>comments 에서 data를 fetching하는 부분에 DataLoader를 적용해서 해결할 수 있다.</p>
<p>GraphQL 에서 DataLoader를 적용하는 순서는 다음과 같다.</p>
<ol>
<li>load할 data에 따라 <code>batchLoadFn</code> 를 작성한다.</li>
<li>Context에서 해당 DataLoader 객체를 생성한다.</li>
<li>resolver에서 context의 DataLoader를 통해서 <code>load</code>를 호출한다.</li>
</ol>
<p>DataLoader의 instance는 자체적으로 <code>cacheMap</code> 을 가지고 있다. 같은 key에 대한 요청이 들어오면 caching된 값을 사용하게 되는데 web application에서 이런방식은 위험할 수 있다. 이러한 이유로 매 request마다 새로운 DataLoader 객체를 생성해서 사용하는것을 권장하고 있다.</p>
<p><code>CommentsLoader</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> batchLoadFn = <span class="keyword">async</span> (postIds) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> comments = <span class="keyword">await</span> Comment.find(&#123; <span class="attr">where</span>: &#123; <span class="attr">postId</span>: In(postIds) &#125; &#125;)</span><br><span class="line">  <span class="keyword">return</span> postIds.map(<span class="function"><span class="params">id</span> =&gt;</span> comments.filter(<span class="function"><span class="params">c</span> =&gt;</span> c.postId === id))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> commentsLoader = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> DataLoader(batchLoadFn)</span><br></pre></td></tr></table></figure></p>
<p><code>Context</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> ApolloServer(&#123;</span><br><span class="line">  ...,</span><br><span class="line">  context: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    loaders: &#123;</span><br><span class="line">      commentsLoader: commentsLoader()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>Resolver</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">comments: <span class="keyword">async</span> (root, _, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> context.loaders.commentsLoader.load(root.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위와같이 DataLoader를 적용하면 comments resolver에서의 모든 load 요청은 하나의 요청으로 묶여서 실행되서 성능문제가 해결된다. 또한 data를 초기에 모두 fetch하지 않고 lazy하게 유지할 수 있기 때문에 역할에 맞게 resolver를 분리해서 복잡성을 줄일 수 있다.</p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>DataLoader를 적용하는 것은 큰 어려움이 없었던 것 같다. 처음엔 동작방식이 좀 난해하게 느껴졌는데 라이브러리 코드를 읽고나서 보니 Promise의 이점과 event-loop의 특성을 이용하는 부분이 인상적이였다.</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://github.com/graphql/dataloader" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/graphql/dataloader</a></li>
<li><a href="https://medium.com/gaplabs-engineering/make-more-efficient-requests-with-dataloader-96ff50eb8998" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/gaplabs-engineering/make-more-efficient-requests-with-dataloader-96ff50eb8998</a></li>
<li><a href="https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/" rel="external nofollow noopener noreferrer" target="_blank">https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/</a></li>
<li><a href="https://engineering.shopify.com/blogs/engineering/solving-the-n-1-problem-for-graphql-through-batching" rel="external nofollow noopener noreferrer" target="_blank">https://engineering.shopify.com/blogs/engineering/solving-the-n-1-problem-for-graphql-through-batching</a></li>
<li><a href="https://github.com/typeorm/typeorm/blob/master/docs/eager-and-lazy-relations.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/typeorm/typeorm/blob/master/docs/eager-and-lazy-relations.md</a></li>
</ul>
</div><div class="article__author" itemscope="" itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.jpg" alt="hosung"><a class="article__author__link" title="About hosung" rel="author">hosung</a><p class="article__author__desc">🔥 Typescript</p><div class="article__author__socials"><a class="article__author__socials__item" href="http://github.com/y0c" title="github" target="_blank" rel="external nofollow noopener noreferrer"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="/feed.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="hosung"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//lazy-developer.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2019-11-24T14:39:33.303Z"><meta itemprop="articleBody" content="이번 포스팅에서는 GraphQL 에서 N+1 문제를 해결하기 위한 솔루션인 DataLoader에 대한 소개와 GraphQL 에 DataLoader를 어떤식으로 적용해야되는지를 정리해보려고 한다.
N+1 문제N+1 문제는 ORM을 사용할때 주로 발생하는 성능 문제이다.
Post 엔티티와 Comment 엔티티가 있다고 가정해보자. 이 엔티티간의 관계는..."><meta itemprop="url" content="https://y0c.github.io/2019/11/24/graphql-query-optimize-with-dataloader/"><meta itemprop="mainEntityOfPage" content="https://y0c.github.io/2019/11/24/graphql-query-optimize-with-dataloader/"><div itemscope="" itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="y0c"><div itemscope="" itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://y0c.github.io/images/logo.png"></div></div><div itemscope="" itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="https://y0c.github.io/images/"><meta itemprop="url" content="https://y0c.github.io/images/"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2019/11/17/graphql-data-mocking/"><div class="related-posts__item__background" style="background-image:url('/images/graphql-mock-data.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">GraphQL Data Mocking</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2019/11/24/graphql-query-optimize-with-dataloader/">GrpahQL DataLoader를 이용한 성능 최적화</a></li><li class="recent-posts__item"><a href="/2019/11/17/graphql-data-mocking/">GraphQL Data Mocking</a></li><li class="recent-posts__item"><a href="/2019/08/25/go-lambda-develop-notify-service/">Golang과 Lambda를 활용한 알림 서비스 개발기</a></li><li class="recent-posts__item"><a href="/2019/08/11/beginning-go/">TDD로 Golang 시작하기</a></li><li class="recent-posts__item"><a href="/2019/07/14/vim-config-for-js-developer/">Vim Configuration 정리</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">2</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tmux/">Tmux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/graphql/">graphql</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/serverless/">serverless</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2019 hosung<br>Powered by <a href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external nofollow noopener noreferrer" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>