<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>React Infinite scroll 구현하기 | y0c</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="https://y0c.github.io/2019/06/30/react-infinite-scroll/">
<meta name="description" content="React로 Infinite scroll을 구현하면서 정리한 글이다.  Infinite scroll?Infinite scroll은 한 번에 모든 컨텐츠를 렌더링 하지 않고 페이지 내용을 아래로 스크롤하면 새로운 컨텐츠를 덧붙여서 렌더링 하는…">
<meta name="keywords" content="React">
<meta property="og:type" content="article">
<meta property="og:title" content="React Infinite scroll 구현하기">
<meta property="og:url" content="https://y0c.github.io/2019/06/30/react-infinite-scroll/">
<meta property="og:site_name" content="y0c">
<meta property="og:description" content="React로 Infinite scroll을 구현하면서 정리한 글이다.  Infinite scroll?Infinite scroll은 한 번에 모든 컨텐츠를 렌더링 하지 않고 페이지 내용을 아래로 스크롤하면 새로운 컨텐츠를 덧붙여서 렌더링 하는…">
<meta property="og:image" content="https://y0c.github.io/images/react-infinite-scroll.png">
<meta property="og:updated_time" content="2019-06-30T10:33:11.241Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React Infinite scroll 구현하기">
<meta name="twitter:description" content="React로 Infinite scroll을 구현하면서 정리한 글이다.  Infinite scroll?Infinite scroll은 한 번에 모든 컨텐츠를 렌더링 하지 않고 페이지 내용을 아래로 스크롤하면 새로운 컨텐츠를 덧붙여서 렌더링 하는…">
<meta name="twitter:image" content="https://y0c.github.io/images/react-infinite-scroll.png"><meta property="article:author" content="hosung"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2019-06-30 16:00:05"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="hosung"><link rel="icon" href="/images/logo.png"><link rel="alternate" href="/feed.xml" type="application/atom+xml" title="y0c"><script>(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-112029921-1', 'auto');
ga('send', 'pageview');</script></head><body itemscope="" itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.png" alt="y0c"><span class="menu__item__link--brand__label">y0c</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope="" itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope="" itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">React Infinite scroll 구현하기</h1><div class="article__meta"><time class="article__meta__time" datetime="2019-06-30T07:00:05.000Z" itemprop="datePublished">2019-06-30 16:00:05</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/React/">React</a></div></div><div class="article__contents"><img src="/images/react-infinite-scroll.png"><p>React로 Infinite scroll을 구현하면서 정리한 글이다. </p>
<h2 id="Infinite-scroll"><a href="#Infinite-scroll" class="headerlink" title="Infinite scroll?"></a>Infinite scroll?</h2><p>Infinite scroll은 한 번에 모든 컨텐츠를 렌더링 하지 않고 페이지 내용을 아래로 스크롤하면 새로운 컨텐츠를 덧붙여서 렌더링 하는 방식이다. 로딩해야할 컨텐츠의 양이 많다면 퍼포먼스 측면에서 infinite scroll을 고려해 볼 수 있다. 페이스북 혹은 트위터와 같은 사이트를 보면 이와 같은 UI를 적극적으로 사용하고 있다. </p>
<h2 id="구현-방법"><a href="#구현-방법" class="headerlink" title="구현 방법"></a>구현 방법</h2><p>Infinite Scroll을 구현하는 방법에는 크게 두 가지가 있다. </p>
<ul>
<li>onScroll event</li>
<li>Intersection Observer API</li>
</ul>
<h3 id="onScroll-event"><a href="#onScroll-event" class="headerlink" title="onScroll event"></a>onScroll event</h3><p>onScroll event를 이용한 방법은 가장 먼저 생각해 볼 수 있는 방법이다. 사용자가 scroll을 할 때 이벤트가 발생하고 현재 scroll 위치가 페이지에 끝에 닿았는지 판단한다. 페이지 끝에 도달했다면 새로운 컨텐츠를 로딩하기 위한 요청을 하고 컨텐츠를 덧붙이는 방식이다. 하지만 scroll 이벤트는 굉장히 빈번하게 발생하기 때문에 성능 최적화를 위해서 <code>throttle</code>과 같은 처리가 필요하다. </p>
<h3 id="Intersection-Observer-API"><a href="#Intersection-Observer-API" class="headerlink" title="Intersection Observer API"></a>Intersection Observer API</h3><p>Intersection Observer는 MDN 에서 아래와 같이 설명한다. </p>
<blockquote>
<p>교차 영역 관찰자 API는 조상 엘리먼트 또는 최상위 도큐먼트 뷰포트와 대상 엘리먼트의 교차 영역에서 발생한 변경 사항을 비동기적으로 감시하는 방법을 제공한다.</p>
</blockquote>
<p>위 정의만 읽어보면 말이 어려울 수 있는데 단순하게 DOM 엘리먼트 간에 영역이 겹쳐지는걸 감시한다고 볼 수 있다. </p>
<p>Intersection Observer API를 사용하면 scroll, resize와 같은 비싼 비용의 이벤트를 좀 더 쉽고 좋은 퍼포먼스로 사용할 수 있다. Lazy-load, infinite scroll 과 같은 것들을 구현할때 유용하게 사용할 수 있다. scroll 이벤트에 비해 단점이라면 아직 모든 브라우저에서 지원하지 않는다는 것이다. </p>
<p>이 글에선 IntersectionObserver 에 대한 자세한 설명은 하지 않는다. 더 필요한 정보는 아래 링크를 참고하도록 하자. </p>
<p><a href="https://velog.io/@doondoony/IntersectionObserver" rel="external nofollow noopener noreferrer" target="_blank">https://velog.io/@doondoony/IntersectionObserver</a></p>
<p>사실 브라우저 지원과 특수한 상황을 제외하곤 Intersection Observer API가 구현하기 편리하기 때문에 이 방법을 통해서 Infinite scroll을 구현하였다. </p>
<h2 id="React를-통한-구현"><a href="#React를-통한-구현" class="headerlink" title="React를 통한 구현"></a>React를 통한 구현</h2><p>구현하려고 했던 것은 Unsplash API를 통해서 이미지를 검색하고 결과를 Infinite scroll 을 통해 보여주는 것이였다. </p>
<h3 id="Component-구조"><a href="#Component-구조" class="headerlink" title="Component 구조"></a>Component 구조</h3><p>가장 먼저 했던 작업은 Component 구조를 잡는 것 이였다.<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UnsplashContainer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;SearchForm</span><br><span class="line">        onSearch=&#123;searchImage&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ScrollContainer</span><br><span class="line">        height=&#123;<span class="number">400</span>&#125;</span><br><span class="line">        vertical</span><br><span class="line">        ref=&#123;rootRef&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;ThumbnailList</span><br><span class="line">          thumbnails=&#123;images&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Loading show=&#123;loading&#125;/&gt;</span><br><span class="line">        &lt;div ref=&#123;targetRef&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ScrollContainer&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>컴포넌트 구조는 scroll 가능한 div를 셋팅해두고 그 아래에 컨텐츠 목록, 로딩 컴포넌트 그리고 마지막으로 IntersectionObserver 를 활용해서 페이지 끝을 감지하기 위해 빈 div를 추가하였다. </p>
<h3 id="React-State"><a href="#React-State" class="headerlink" title="React State"></a>React State</h3><p>이제 Component에서 필요한 변수, 상태, ref를 추가해야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instance variable</span></span><br><span class="line"><span class="keyword">const</span> currentPage = useRef(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> totalPage = useRef(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// request state</span></span><br><span class="line"><span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> [error, setError] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// contents list</span></span><br><span class="line"><span class="keyword">const</span> [images, setImages] = useState([]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref</span></span><br><span class="line"><span class="keyword">const</span> rootRef = useRef(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> targetRef = useRef(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>currentPage와 totalPage는 state로 관리할 필요는 없었기 때문에 Ref로 추가하였다.<br>(React Hooks에서 useRef는 이전값을 저장하거나 class component의 멤버 변수와 같이 사용할 수 있다.)<br>rootRef와 targetRef는 IntersectionObserver에서 사용할 실제 DOM 노드들이다. </p>
<h3 id="Data-Fetching"><a href="#Data-Fetching" class="headerlink" title="Data Fetching"></a>Data Fetching</h3><p>Data Fetching을 위한 함수를 몇가지 정의한다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadImage = useCallback(<span class="keyword">async</span> (&#123; query, page &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      setLoading(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> UnsplashAPI.searchPhotos(&#123; query, page, <span class="attr">per_page</span>: PER_PAGE&#125;);</span><br><span class="line">      totalPage.current = data.total_pages;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      setError(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      setLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> searchImage = useCallback(<span class="keyword">async</span> (query) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(!query) &#123;</span><br><span class="line">    <span class="keyword">await</span> loadRandomImage();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  currentQuery.current = query;</span><br><span class="line">  currentPage.current = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> loadImage(&#123; query, <span class="attr">page</span>: <span class="number">1</span>, <span class="attr">per_page</span>: PER_PAGE &#125;);</span><br><span class="line">  setImages(data.results);</span><br><span class="line">&#125;, [loadImage, loadRandomImage]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadMoreImage = useCallback(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(images.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    currentPage.current++;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> loadImage(&#123;</span><br><span class="line">      query: currentQuery.current,</span><br><span class="line">      page: currentPage.current</span><br><span class="line">    &#125;);</span><br><span class="line">    setImages([...images, ...data.results])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,[images, loadImage]);</span><br></pre></td></tr></table></figure>
<p>loadImage는 Unsplash API를 통해서 Data를 가져오고 loading과 error 상태를 제어한다. searchImage는 맨 처음 데이터 요청에만 사용한다. 폼에서 검색을 실행하면 이 함수가 호출된다. loadMoreImage 함수는 스크롤이 끝에 닿았을때 호출된다. 여기선 페이지값을 증가시키고 컨텐츠 뒤쪽으로 새로운 컨텐츠를 붙여주면 된다. </p>
<p>(<code>useAsyncFn</code> hook을 사용하면 loading, error를 좀 더 깔끔하게 관리할 수 있다. <code>react-use</code> 패키지에서 사용하거나 혹은 구현해도 무관하다.)</p>
<h3 id="IntersectionObserver-hook"><a href="#IntersectionObserver-hook" class="headerlink" title="IntersectionObserver hook"></a>IntersectionObserver hook</h3><p>IntersectionObserver를 설정해준다. 이 부분은 검색해보면 라이브러리도 많고 일반적인 예제들도 많이 있다. 상황에 맞춰서 사용하면 될 것 같다. 나는 다른 코드를 참고해서 custom hook을 추가했다. </p>
<p><code>useIntersectionObserver.jsx</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; root, target, onIntersect, threshold = <span class="number">1.0</span>, rootMargin = <span class="string">"0px"</span> &#125;) =&gt; &#123;</span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(onIntersect, &#123;</span><br><span class="line">        root,</span><br><span class="line">        rootMargin,</span><br><span class="line">        threshold,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      observer.observe(target);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        observer.unobserve(target);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;, [target, root, rootMargin, onIntersect, threshold]</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>root, threshold, rootMargin은 IntersectionObserver의 옵션들이고 target은 교차에 대해서 감시할 element 이다. onIntersect는 IntersectionObserver의 callback이라고 생각하면 된다. </p>
<p>위 컴포넌트 구조에서 root는 ScrollContainer로 target은 맨끝에 빈 div로 설정하였다. onIntersect 에서 몇가지 조건에 맞춰서 loadMoreImage를 호출해주면 infinite scroll이 완성된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">useIntersectionObserver(&#123;</span><br><span class="line">  root: rootRef.current,</span><br><span class="line">  target: targetRef.current,</span><br><span class="line">  onIntersect: <span class="function">(<span class="params">[&#123;isIntersecting&#125;]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">      isIntersecting &amp;&amp;</span><br><span class="line">      !loading &amp;&amp;</span><br><span class="line">      currentPage.current &lt; totalPage.current</span><br><span class="line">    ) &#123;</span><br><span class="line">      loadMoreImage();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>나는 위와 같은 조건을 추가해서 구현했다. 로딩중이거나 마지막 페이지가 아닐때 페이지끝에 닿으면 추가로 로딩하는 로직이다. </p>
<h2 id="구현-화면"><a href="#구현-화면" class="headerlink" title="구현 화면"></a>구현 화면</h2><img src="/2019/06/30/react-infinite-scroll/infinite_scroll.gif" title="구현화면">
<p>이 프로젝트는 블로그 포스트 배너를 생성해주는 <a href="https://github.com/banner-maker/banner-maker" rel="external nofollow noopener noreferrer" target="_blank">banner-maker</a> 라는 프로젝트이다.<br>Unsplash Image를 배경으로 활용할 수 있도록 기능을 추가해서 기여해 보았다. </p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>scroll event를 활용해서 구현하는 것 보다  IntersectionObserver를 이용하면 좀 더 손쉽게 infinite scroll을 구현할 수 있었다. IntersectionObserver의 브라우저 지원현황이 걸린다면 polyfill을 사용할 수 있지만 완벽하진 않은 것 같다. </p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://velog.io/@doondoony/IntersectionObserver" rel="external nofollow noopener noreferrer" target="_blank">https://velog.io/@doondoony/IntersectionObserver</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API</a></li>
<li><a href="https://github.com/streamich/react-use" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/streamich/react-use</a></li>
</ul>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/React/">React</a></div><div class="article__author" itemscope="" itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.jpg" alt="hosung"><a class="article__author__link" title="About hosung" rel="author">hosung</a><p class="article__author__desc">🔥 Typescript</p><div class="article__author__socials"><a class="article__author__socials__item" href="http://github.com/y0c" title="github" target="_blank" rel="external nofollow noopener noreferrer"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="/feed.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="hosung"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//lazy-developer.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2019-06-30T10:33:11.241Z"><meta itemprop="articleBody" content="React로 Infinite scroll을 구현하면서 정리한 글이다. 
Infinite scroll?Infinite scroll은 한 번에 모든 컨텐츠를 렌더링 하지 않고 페이지 내용을 아래로 스크롤하면 새로운 컨텐츠를 덧붙여서 렌더링 하는 방식이다. 로딩해야할 컨텐츠의 양이 많다면 퍼포먼스 측면에서 infinite scroll을 고려해 볼 수..."><meta itemprop="url" content="https://y0c.github.io/2019/06/30/react-infinite-scroll/"><meta itemprop="mainEntityOfPage" content="https://y0c.github.io/2019/06/30/react-infinite-scroll/"><div itemscope="" itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="y0c"><div itemscope="" itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://y0c.github.io/images/logo.png"></div></div><div itemscope="" itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="https://y0c.github.io/images/react-infinite-scroll.png"><meta itemprop="url" content="https://y0c.github.io/images/react-infinite-scroll.png"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/06/React-Component-생명주기/"><div class="related-posts__item__background" style="background-image:url('/images/react.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">React Component 생명주기</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/03/React-Event-Handling/"><div class="related-posts__item__background" style="background-image:url('/images/react.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">React Event Handling</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/09/10/semantic-ui-react-theme/"><div class="related-posts__item__background" style="background-image:url('/images/react.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Semantic-Ui-React Theme Customizing</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2019/06/30/react-infinite-scroll/">React Infinite scroll 구현하기</a></li><li class="recent-posts__item"><a href="/2019/06/14/monorepo-tutorial/">📦 Monorepo Tutorial</a></li><li class="recent-posts__item"><a href="/2019/04/11/testing-refactoring/">Testing &amp; Refactoring</a></li><li class="recent-posts__item"><a href="/2018/10/22/jenkins-docker-tomcat/">Jenkins x Docker Tomcat War 배포하기</a></li><li class="recent-posts__item"><a href="/2018/10/21/redis-cluster/">Redis Cluster 구축하기</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">2</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tmux/">Tmux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/serverless/">serverless</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2019 hosung<br>Powered by <a href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external nofollow noopener noreferrer" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>