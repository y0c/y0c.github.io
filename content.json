{"meta":{"title":"Lazy Developer","subtitle":null,"description":"Web Developer & Student","author":"HoSung","url":"https://y0c.github.io"},"pages":[],"posts":[{"title":"React Component 생명주기","slug":"React-Component-생명주기","date":"2018-01-05T23:53:57.000Z","updated":"2018-01-05T23:59:05.874Z","comments":true,"path":"2018/01/06/React-Component-생명주기/","link":"","permalink":"https://y0c.github.io/2018/01/06/React-Component-생명주기/","excerpt":"","text":"목차 Component LifeCycle - Mounting Component LifeCycle - Updating Component LifeCycle - Unmounting Web Service, Mobile App 또는 다른 Application을 개발해봤다면 생명주기 라는말을 한 번쯤 들어보았을 것이다. 혹시 들어보지 못했더라도 전혀 상관없다!생명주기란 Application 이 시작, 실행, 활성, 비활성, 정지, 종료 등 일련의 상태를 순환하는데 이것을 생명주기라고 한다. React 에서도 마찬가지로 Component가 생성, 수정, 소멸 크게 3가지 부분으로 나뉘어서 LifeCycle API 가 제공되고 있는데. 이것들을 기억해두셨다가 개발도중에 필요할때 적절하게 구현해놓고 사용하면 된다. Component LifeCycle - Mounting 컴포넌트가 생성될때 호출되는 LifeCycle API 이다.생성자 메소드의 경우 ES6를 사용하지 않는다면 getInitialState 메소드를 사용하실 수 있고 더 자세한 내용은 React 공식문서 React Without ES6 를 참고하도록 하자. Component LifeCycle - Updating 컴포넌트가 생성될때 호출되는 LifeCycle API 이다.여기서 shouldComponentUpdate 메소드는 중요한 역활을 한다.이 메소드에서 변경된 props와 state를 통해 리렌더링을 할지 여부를 결정하게 되는데 기본적으로 true를 리턴하게 되있는데 false를 리턴할경우 렌더링을 하지 않는다. 123shouldComponentUpdate( nextProps, nextState ) &#123; return nextProps.list !== this.props.list&#125; 위 코드는 shouldComponentUpdate를 통해 이전 props와 변경될 props를 비교해서 렌더링 여부를 결정하는 예시이다. 여기서 기억해두어야할 점은 React에서는deep checking이나 JSON.stringfiy() 메소드를 통한 비교는 권장하지 않는다는 것이다.이는 비효율적이고 성능에 영향을 끼치기 때문에 일반적으로 shallow checking을 사용하고 있다. deep checking , shallow checking, immutable fashion 에 관해서는 다른 글을 통해서 더 자세히 다뤄볼 수 있도록 준비할 예정이다. React.PureComponent를 상속받게되면 props와 state에 대해 shallow compare로직이 들어가 있어서 좀 더 편리하게 사용할 수 있다고 한다.하지만 무분별하게 PureComponent를 상속받아서 사용한다면 오히려 성능저하를 야기할 수 있고 적절히 필요한곳에 shouldComponentUpdate를 구현하여 사용하시는 것이 좋은 방법이라고 생각된다. 그리고 설사 shouldComponentUpdate를 구현하지 않아서 무조건 true를 리턴하는 상황이 있다고 하더라도 React는 모든경우에 리렌더링을 하지는 않는다. shouldComponentUpdate를 통해 true를 리턴하게 되면 기존 Vitural DOM과 변경된 props나 state를 통해 만들어질 Vitural DOM과 비교하여 변경된 내용이 없다면 리렌더링을 하지 않는다. 하지만 규모가 커질수록 큰 성능 차이를 낼 수 있기 때문에 최적화 하는 습관을 들여놓는게 좋다고 생각한다. Component LifeCycle - Unmounting 컴포넌트가 소멸될시 호출되는 LifeCycle API입니다.위 설명과 같이 타이머 제거, 네트워크 요청취소, 이벤트 리스너 제거등에 주로 사용된다. 개인 공부용으로 쓴 글이라 혹시 잘못된 정보가 있다면 댓글로 알려주시면 수정하도록하겠습니다.","categories":[{"name":"React","slug":"React","permalink":"https://y0c.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://y0c.github.io/tags/React/"}]},{"title":"React Event Handling","slug":"React-Event-Handling","date":"2018-01-03T14:30:05.000Z","updated":"2018-01-05T23:59:05.878Z","comments":true,"path":"2018/01/03/React-Event-Handling/","link":"","permalink":"https://y0c.github.io/2018/01/03/React-Event-Handling/","excerpt":"","text":"목차 React 와 일반적인 DOM element 에서 이벤트 핸들링의 차이 React에서 Event를 바인딩하는 여러가지 방법 SyntheticEvent React 와 일반적인 DOM element 에서 이벤트 핸들링의 차이React에서 이벤트를 핸들링하는 방법은 DOM elements의 이벤트를 핸들링 하는 방법과 매우 유사하다. 아래 가장 기본적인 예시를 보도록 하자.먼저 일반적인 DOM Element의 바인딩 하는 방법이다.123&lt;button onclick=\"activeLasers()\"&gt; Activate Lasers&lt;/button&gt; 위와 같이 표현할 수 있다. 같은 역활을 하는 Element를 React Way로 표현하면 다음과 같다.123&lt;button onClick=&#123;this.activeLaser&#125;&gt; Activate Lasers&lt;/button&gt; 첫 번째 차이점은 React에서는 Event를 CamelCase를 사용하여 표기한다는 점이다.두번째로 일반적인 DOM에서 이벤트를 바인딩 할 때에는 function을 직접 호출하지만 React는 이벤트를 직접 호출하지않고 function을 지정해주기만 한다.(즉 function 의 포인터 만 넘겨주고 직접 핸들링하지 않는다.) return false; 에 관해DOM element에 이벤트를 바인딩 한 경험이 있다면 return false; 를 많이 사용해봤을 것이다. 이 return false;의 역활은 브라우저의 기본동작을 막아주도록 동작한다.즉 event.preventDefault와 같은 역활을 한다고 볼 수 있다. 같은 syntax 를 jQuery event handler 안에서 사용할 경우event.preventdefault() 와 event.stopPropagation()을 동시에 처리해준다. 하지만 React의 경우 return false와 같은 syntax는 아무 동작을 하지 않는다.반드시 기본동작이나 버블링을 제어할 시에는 명시적으로 event.preventDefault()event.stopPropagation()을 작성해주어야 한다. React 에서 Event를 바인딩하는 여러가지 방법에 관하여Event Handler 에서 thisES6 Class syntax를 사용하여 React Component를 작성한 경우 event handler에서 this는 undefined가 된다. 왜냐하면 javascript에서 this는 호출한 context에 의해 결정되기 때문이다.만약 잘 이해가 가지 않는다면 아래 문서를 참고하도록 하자. this - JavaScript | MDN 이러한 this 에 관한 이슈로 인해 this를 이벤트 핸들러가 아닌 클래스에 바인딩 할 수 있는 몇가지 방법을 소개해볼까한다. 1. React.createClassReact 의 createClass 메소드를 사용하여 컴포넌트를 제작할경우 react는 모든 함수를 this에 자동으로 바인딩한다.즉 따로 바인딩 할 필요가 없지만 React.createClass syntax는 조만간 이후 버전의 릴리즈에서 추출 될 수 있으므로 지양하는 것이 좋다. 2. Rendering 시 바인딩1onChange=&#123;this.handleChange.bind(this)&#125; 위와 같이 렌더링시에 바로 this에 바인딩 해주는 방법도 있는데 이는 렌더링이 실행될때마다 새로운 함수를 만들어주기 때문에 퍼포먼스에 좋지 않다고 한다. 3. Constructor를 통한 바인딩1234constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this);&#125; 생성자 함수에서 함수를 바인딩해주는 방법이다. 생성자 호출 될시 한번만 바인딩 되므로 퍼포먼스 이슈가 없고 React에서 권장하는 가장 일반적인 방법인데이벤트 핸들러가 많아지면 바인딩을 못한 휴먼에러가 생길 수 있고 매 번 바인딩을 하는 것은 꽤나 부담스럽고 귀찮은 작업이 될 수도 있다. 4. Class Property 의 Arrow Function 을 통한 바인딩123handleChange = () =&gt; &#123;&#125; 위와 같은 방법은 가장 심플하게 함수를 클래스에 바인딩 할 수 있는 방법을 제공하는데해당 syntax를 사용하기 위해서는 babel state-2 혹은 transfrom-class-properties 가 추가되있어야 정상적으로 동작한다. 참고123456789101112131415161718192021222324class Bork &#123; //Property initializer syntax instanceProperty = \"bork\"; boundFunction = () =&gt; &#123; return this.instanceProperty; &#125; //Static class properties static staticProperty = \"babelIsCool\"; static staticFunction = function() &#123; return Bork.staticProperty; &#125; &#125; let myBork = new Bork; //Property initializers are not on the prototype. console.log(myBork.__proto__.boundFunction); // &gt; undefined //Bound functions are bound to the class instance. console.log(myBork.boundFunction.call(undefined)); // &gt; \"bork\" //Static function exists on the class. console.log(Bork.staticFunction()); // &gt; \"babelIsCool\" 위 코드는 babel 공식문서에서 발췌한 코드이다.Class properties transform · Babel 코드에 있는 설명에는 Property initializer 를 통한 Arrow Function은 Prototype에 추가되지 않는다. 즉, Prototype 에 추가되지 않는 다는 의미는 클래스가 생성될때마다 메모리 공간을 차지하고 상속을 하지 못하는 문제점이 존재한다. 개인적인 생각으로는 이벤트 핸들러는 React Component 중에서도 주로 컨테이너 즉 Statefull Component 에 주로 바인딩 되고 props를 통해서 하위 컴포넌트로 핸들러를 전달한다. 컨테이너 특성상 자주 생성되지 않고 이벤트 핸들러는 일반적으로 상속이 자주 사용되지 않아서 단점보다 auto-binding을 통한 편리함과 장점이 크다고 생각하기 때문에 앞으로도 위와 같은 syntax를 자주 사용할 것 같다.저런 방법 마저 마음에 들지 않는다면 react-autobind, autobind-decorator 와 같은 라이브러리들이 있으니 참고하도록 하자. SyntheticEventReact 에서는 DOM 이벤트를 직접다루지 않고 이를 Wrapping한 SyntheticEvent를 사용한다. 이 SyntheticEvent 를 사용함으로써 브라우저마다 다른 event 객체에 대해 신경쓸 필요가 없다! 즉 크로스 브라우징에 관한 이슈가 해결된다.SyntheticEvent 에 관한 속성들은 따로 언급하진 않겠다.DOM 이벤트와 완벽하게 매칭되는게 아니므로 찾아볼 게 있을때는 React 공식문서를 참조하도록 하자.SyntheticEvent - React 개인 공부용으로 쓴 글이라 혹시 잘못된 정보가 있다면 댓글로 알려주시면 수정하도록하겠습니다.","categories":[{"name":"React","slug":"React","permalink":"https://y0c.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://y0c.github.io/tags/React/"},{"name":"Event Handling","slug":"Event-Handling","permalink":"https://y0c.github.io/tags/Event-Handling/"}]}]}