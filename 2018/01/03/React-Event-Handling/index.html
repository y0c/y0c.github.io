<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>React Event Handling | Lazy Developer</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="https://y0c.github.io/2018/01/03/React-Event-Handling/">
<meta name="description" content="목차 React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이 React에서 Event를 바인딩하는 여러가지 방법 SyntheticEvent     React 와 일반적인  DOM element 에서 이벤트 핸들링의…">
<meta name="keywords" content="React,Event Handling">
<meta property="og:type" content="article">
<meta property="og:title" content="React Event Handling">
<meta property="og:url" content="https://y0c.github.io/2018/01/03/React-Event-Handling/">
<meta property="og:site_name" content="Lazy Developer">
<meta property="og:description" content="목차 React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이 React에서 Event를 바인딩하는 여러가지 방법 SyntheticEvent     React 와 일반적인  DOM element 에서 이벤트 핸들링의…">
<meta property="og:image" content="https://y0c.github.io/images/react.jpg">
<meta property="og:updated_time" content="2018-09-09T13:47:47.579Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React Event Handling">
<meta name="twitter:description" content="목차 React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이 React에서 Event를 바인딩하는 여러가지 방법 SyntheticEvent     React 와 일반적인  DOM element 에서 이벤트 핸들링의…">
<meta name="twitter:image" content="https://y0c.github.io/images/react.jpg"><meta property="article:author" content="HoSung"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-01-03 23:30:05"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="HoSung"><link rel="icon" href="/images/logo.svg"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="Lazy Developer"><script>(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-112029921-1', 'auto');
ga('send', 'pageview');</script></head><body itemscope="" itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.svg" alt="Lazy Developer"><span class="menu__item__link--brand__label">Lazy Developer</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope="" itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope="" itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">React Event Handling</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-01-03T14:30:05.000Z" itemprop="datePublished">2018-01-03 23:30:05</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/React/">React</a></div></div><div class="article__contents"><img src="/images/react.jpg"><hr>
<h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><ol>
<li><a href="#react-dom-difference">React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이</a></li>
<li><a href="#react-event-bind-method">React에서 Event를 바인딩하는 여러가지 방법</a></li>
<li><a href="#react-synthetic-event">SyntheticEvent</a></li>
</ol>
<hr>
<div id="react-dom-difference"><br></div>

<h2 id="React-와-일반적인-DOM-element-에서-이벤트-핸들링의-차이"><a href="#React-와-일반적인-DOM-element-에서-이벤트-핸들링의-차이" class="headerlink" title="React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이"></a>React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이</h2><p>React에서 이벤트를 핸들링하는 방법은 DOM elements의 이벤트를 핸들링 하는 방법과 매우 유사하다.  아래 가장 기본적인 예시를 보도록 하자.<br>먼저 일반적인 <code>DOM Element</code>의 바인딩 하는 방법이다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"activeLasers()"</span>&gt;</span></span><br><span class="line">	Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>위와 같이 표현할 수 있다.</p>
<p>같은 역활을 하는 Element를 <code>React Way</code>로 표현하면 다음과 같다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.activeLaser&#125;</span>&gt;</span></span><br><span class="line">	Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>첫 번째 차이점은 React에서는 Event를 <em>CamelCase</em>를 사용하여 표기한다는 점이다.<br>두번째로 일반적인 DOM에서 이벤트를 바인딩 할 때에는 function을 직접 호출하지만 React는 이벤트를 직접 호출하지않고 function을 지정해주기만 한다.<br>(즉 function 의 포인터 만 넘겨주고 직접 핸들링하지 않는다.)</p>
<h3 id="return-false-에-관해"><a href="#return-false-에-관해" class="headerlink" title="return false; 에 관해"></a>return false; 에 관해</h3><p>DOM element에 이벤트를 바인딩 한 경험이 있다면 <code>return false;</code> 를 많이 사용해봤을 것이다. 이 <code>return false;</code>의 역활은 브라우저의 기본동작을 막아주도록 동작한다.<br>즉 <code>event.preventDefault</code>와 같은 역활을 한다고 볼 수 있다.</p>
<p>같은 syntax 를 jQuery event handler 안에서 사용할 경우<br><code>event.preventdefault()</code> 와 <code>event.stopPropagation()</code>을 동시에 처리해준다.</p>
<p><strong>하지만 React의 경우 return false와 같은 syntax는 아무 동작을 하지 않는다.</strong><br>반드시 기본동작이나 버블링을 제어할 시에는 명시적으로 <code>event.preventDefault()</code><br><code>event.stopPropagation()</code>을 작성해주어야 한다.</p>
<hr>
<div id="react-event-bind-method"><br></div>

<h2 id="React-에서-Event를-바인딩하는-여러가지-방법에-관하여"><a href="#React-에서-Event를-바인딩하는-여러가지-방법에-관하여" class="headerlink" title="React 에서 Event를 바인딩하는 여러가지 방법에 관하여"></a>React 에서 Event를 바인딩하는 여러가지 방법에 관하여</h2><p><strong>Event Handler 에서 this</strong><br>ES6 Class syntax를 사용하여 React Component를 작성한 경우 event handler에서 this는 undefined가 된다. 왜냐하면 javascript에서 this는 호출한 context에 의해 결정되기 때문이다.<br>만약 잘 이해가 가지 않는다면 아래 문서를 참고하도록 하자.</p>
<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this" rel="external nofollow noopener noreferrer" target="_blank">this - JavaScript | MDN</a></p>
<p>이러한 this 에 관한 이슈로 인해 this를 이벤트 핸들러가 아닌 클래스에 바인딩 할 수 있는 몇가지 방법을 소개해볼까한다.</p>
<p><strong>1. React.createClass</strong><br>React 의 createClass 메소드를 사용하여 컴포넌트를 제작할경우 react는 모든 함수를 this에 자동으로 바인딩한다.<br>즉 따로 바인딩 할 필요가 없지만 React.createClass syntax는 조만간 이후 버전의 릴리즈에서 추출 될 수 있으므로 지양하는 것이 좋다.</p>
<p><strong>2. Rendering 시 바인딩</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onChange=&#123;<span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>)&#125;</span><br></pre></td></tr></table></figure></p>
<p>위와 같이 렌더링시에 바로 this에 바인딩 해주는 방법도 있는데 이는 렌더링이 실행될때마다 새로운 함수를 만들어주기 때문에 퍼포먼스에 좋지 않다고 한다.</p>
<p><strong>3. Constructor를 통한 바인딩</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>생성자 함수에서 함수를 바인딩해주는 방법이다. 생성자 호출 될시 한번만 바인딩 되므로 퍼포먼스 이슈가 없고 React에서 권장하는 가장 일반적인 방법인데<br>이벤트 핸들러가 많아지면 바인딩을 못한 휴먼에러가 생길 수 있고 매 번 바인딩을 하는 것은 꽤나 부담스럽고 귀찮은 작업이 될 수도 있다.</p>
<p><strong>4. Class Property 의 Arrow Function 을 통한 바인딩</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위와 같은 방법은 가장 심플하게 함수를 클래스에 바인딩 할 수 있는 방법을 제공하는데<br>해당 syntax를 사용하기 위해서는 babel <em>state-2</em> 혹은 <em>transfrom-class-properties</em> 가 추가되있어야 정상적으로 동작한다.</p>
<p><em>참고</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bork</span> </span>&#123;</span><br><span class="line">   <span class="comment">//Property initializer syntax</span></span><br><span class="line">   instanceProperty = <span class="string">"bork"</span>;</span><br><span class="line">   boundFunction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.instanceProperty;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Static class properties</span></span><br><span class="line">   <span class="keyword">static</span> staticProperty = <span class="string">"babelIsCool"</span>;</span><br><span class="line">   <span class="keyword">static</span> staticFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Bork.staticProperty;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> myBork = <span class="keyword">new</span> Bork;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Property initializers are not on the prototype.</span></span><br><span class="line"> <span class="built_in">console</span>.log(myBork.__proto__.boundFunction); <span class="comment">// &gt; undefined</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Bound functions are bound to the class instance.</span></span><br><span class="line"> <span class="built_in">console</span>.log(myBork.boundFunction.call(<span class="literal">undefined</span>)); <span class="comment">// &gt; "bork"</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Static function exists on the class.</span></span><br><span class="line"> <span class="built_in">console</span>.log(Bork.staticFunction()); <span class="comment">// &gt; "babelIsCool"</span></span><br></pre></td></tr></table></figure></p>
<p> 위 코드는 babel 공식문서에서 발췌한 코드이다.<br><a href="https://babeljs.io/docs/plugins/transform-class-properties/" rel="external nofollow noopener noreferrer" target="_blank">Class properties transform · Babel</a></p>
<p>코드에 있는 설명에는 Property initializer 를 통한 Arrow Function은 Prototype에 추가되지 않는다. 즉, Prototype 에 추가되지 않는 다는 의미는 클래스가 생성될때마다 메모리 공간을 차지하고 상속을 하지 못하는 문제점이 존재한다.</p>
<p>개인적인 생각으로는 이벤트 핸들러는 React Component 중에서도 주로 컨테이너 즉 Statefull Component 에 주로 바인딩 되고 props를 통해서 하위 컴포넌트로 핸들러를 전달한다. 컨테이너 특성상 자주 생성되지 않고 이벤트 핸들러는 일반적으로 상속이 자주 사용되지 않아서 단점보다 auto-binding을 통한 편리함과 장점이 크다고 생각하기 때문에 앞으로도 위와 같은 syntax를 자주 사용할 것 같다.<br>저런 방법 마저 마음에 들지 않는다면 <code>react-autobind</code>, <code>autobind-decorator</code> 와 같은 라이브러리들이 있으니 참고하도록 하자.</p>
<hr>
<div id="react-synthetic-event"><br></div>


<h2 id="SyntheticEvent"><a href="#SyntheticEvent" class="headerlink" title="SyntheticEvent"></a>SyntheticEvent</h2><p>React 에서는 DOM 이벤트를 직접다루지 않고 이를 Wrapping한 <code>SyntheticEvent</code>를 사용한다. 이 <code>SyntheticEvent</code> 를 사용함으로써 <strong>브라우저마다 다른 event 객체에 대해 신경쓸 필요가 없다!</strong> 즉 크로스 브라우징에 관한 이슈가 해결된다.<br>SyntheticEvent 에 관한 속성들은 따로 언급하진 않겠다.<br>DOM 이벤트와 완벽하게 매칭되는게 아니므로 찾아볼 게 있을때는 React 공식문서를 참조하도록 하자.<br><a href="https://reactjs.org/docs/events.html" rel="external nofollow noopener noreferrer" target="_blank">SyntheticEvent - React</a></p>
<hr>
<h3 id="개인-공부용으로-쓴-글이라-혹시-잘못된-정보가-있다면-댓글로-알려주시면-수정하도록하겠습니다"><a href="#개인-공부용으로-쓴-글이라-혹시-잘못된-정보가-있다면-댓글로-알려주시면-수정하도록하겠습니다" class="headerlink" title="개인 공부용으로 쓴 글이라 혹시 잘못된 정보가 있다면 댓글로 알려주시면 수정하도록하겠습니다."></a>개인 공부용으로 쓴 글이라 혹시 잘못된 정보가 있다면 댓글로 알려주시면 수정하도록하겠습니다.</h3></div><div class="article__tags"><a class="article__tags__item" href="/tags/React/">React</a><a class="article__tags__item" href="/tags/Event-Handling/">Event Handling</a></div><div class="article__author" itemscope="" itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.jpg" alt="HoSung"><a class="article__author__link" title="About HoSung" rel="author">HoSung</a><p class="article__author__desc">Web Developer &amp; Student</p><div class="article__author__socials"><a class="article__author__socials__item" href="http://github.com/y0c" title="github" target="_blank" rel="external nofollow noopener noreferrer"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="HoSung"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//lazy-developer.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-09-09T13:47:47.579Z"><meta itemprop="articleBody" content="
목차
React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이
React에서 Event를 바인딩하는 여러가지 방법
SyntheticEvent




React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이React에서 이벤트를 핸들링하는 방법은 DOM elements의 이벤트를 핸들링 하는 방법과 매우 유사하다. ..."><meta itemprop="url" content="https://y0c.github.io/2018/01/03/React-Event-Handling/"><meta itemprop="mainEntityOfPage" content="https://y0c.github.io/2018/01/03/React-Event-Handling/"><div itemscope="" itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="Lazy Developer"><div itemscope="" itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://y0c.github.io/images/logo.svg"></div></div><div itemscope="" itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="https://y0c.github.io/images/react.jpg"><meta itemprop="url" content="https://y0c.github.io/images/react.jpg"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/01/06/React-Component-생명주기/"><div class="related-posts__item__background" style="background-image:url('/images/react.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">React Component 생명주기</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2018/09/10/semantic-ui-react-theme/"><div class="related-posts__item__background" style="background-image:url('/images/react.jpg');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">Semantic-Ui-React Theme Customizing</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/09/28/centos7-mail-server/">CentOS 7 Mail Server 구축하기 Postfix + Dovecot</a></li><li class="recent-posts__item"><a href="/2018/09/27/tmux-tutorial/">Tmux Tutorial 정리</a></li><li class="recent-posts__item"><a href="/2018/09/10/semantic-ui-react-theme/">Semantic-Ui-React Theme Customizing</a></li><li class="recent-posts__item"><a href="/2018/09/10/js-closure/">Javascript Closure란?</a></li><li class="recent-posts__item"><a href="/2018/09/09/js-generator/">JS의 Generator와 Iterator</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">2</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tmux/">Tmux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/serverless/">serverless</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2018 HoSung<br>Powered by <a href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external nofollow noopener noreferrer" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>