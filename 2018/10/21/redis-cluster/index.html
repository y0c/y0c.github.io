<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Redis Cluster 구축하기 | Lazy Developer</title><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="https://y0c.github.io/2018/10/21/redis-cluster/">
<meta name="description" content="최근에 구축한 서버환경 중 Session Clustering과 Cache의 용도로 Redis를 사용한 적이 있다.하지만 Redis가 설치된 서버가 한개라 해당 서버가 다운되면 모든 WAS가 서비스를 하지못하는 상황이 나오게 된다.이런 문제때문에…">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis Cluster 구축하기">
<meta property="og:url" content="https://y0c.github.io/2018/10/21/redis-cluster/">
<meta property="og:site_name" content="Lazy Developer">
<meta property="og:description" content="최근에 구축한 서버환경 중 Session Clustering과 Cache의 용도로 Redis를 사용한 적이 있다.하지만 Redis가 설치된 서버가 한개라 해당 서버가 다운되면 모든 WAS가 서비스를 하지못하는 상황이 나오게 된다.이런 문제때문에…">
<meta property="og:image" content="https://y0c.github.io/images/redis.png">
<meta property="og:updated_time" content="2018-10-23T06:50:10.119Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis Cluster 구축하기">
<meta name="twitter:description" content="최근에 구축한 서버환경 중 Session Clustering과 Cache의 용도로 Redis를 사용한 적이 있다.하지만 Redis가 설치된 서버가 한개라 해당 서버가 다운되면 모든 WAS가 서비스를 하지못하는 상황이 나오게 된다.이런 문제때문에…">
<meta name="twitter:image" content="https://y0c.github.io/images/redis.png"><meta property="article:author" content="HoSung"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-10-21 10:21:57"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="HoSung"><link rel="icon" href="/images/logo.svg"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="Lazy Developer"><script>(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-112029921-1', 'auto');
ga('send', 'pageview');</script></head><body itemscope="" itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/logo.svg" alt="Lazy Developer"><span class="menu__item__link--brand__label">Lazy Developer</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope="" itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope="" itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">Redis Cluster 구축하기</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-10-21T01:21:57.000Z" itemprop="datePublished">2018-10-21 10:21:57</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/Redis/">Redis</a></div></div><div class="article__contents"><img src="/images/redis.png"><p>최근에 구축한 서버환경 중 Session Clustering과 Cache의 용도로 Redis를 사용한 적이 있다.<br>하지만 Redis가 설치된 서버가 한개라 해당 서버가 다운되면 모든 WAS가 서비스를 하지못하는 상황이 나오게 된다.<br>이런 문제때문에 FailOver처리를 위해 Redis Cluster 구축을 생각하게 되었다.<br>이번 포스팅에선 Redis Cluster를 구축하면서 있었던 문제점과 경험담에 대해 공유해보려 한다.</p>
<p>Redis 는 기본적으로 손쉽게 Replication을 구성해서 장애대비를 할 수 있다.<br>Master/Slave구조를 갖게되는데 Master는 Read/Write 모두가능하고 Slave는 Read Only이다.<br>상황에 따라서 Read Only Connection만 필요한경우도 있을테지만 이런구조에서는 Master가 Down되면 수동으로<br>Master를 복구해주어야 한다.</p>
<p>이런상황을 막기위한 솔루션으로 Redis Sentinel 과 Redis Cluster 라는 솔루션이 있는데<br>이 두 가지 솔루션중 선택은 상황에 맞게 써주면 좋을 것 같다. Sentinel 에 관해선 따로 포스팅을 작성해 보려한다.<br>이번글에선 Redis Cluster 솔루션에 대해 다뤄보려고 한다.</p>
<h2 id="Redis-Cluster가-제공하는-기능"><a href="#Redis-Cluster가-제공하는-기능" class="headerlink" title="Redis Cluster가 제공하는 기능"></a>Redis Cluster가 제공하는 기능</h2><ul>
<li>Dataset을 여러노드에 분산해서 저장</li>
<li>Auto FailOver( Master - Slave ) 구조를 통해 해결</li>
</ul>
<h2 id="Redis-Cluster-TCP-Port"><a href="#Redis-Cluster-TCP-Port" class="headerlink" title="Redis Cluster TCP Port"></a>Redis Cluster TCP Port</h2><p>Redis Cluster는 두개의 TCP Port를 사용하여 통신한다. 기본포트인 6379 혹은 다른포트여도 상관없다.<br>그리고 Node간 통신을 위한포트인 16379 가 사용되는데 이 두 포트 사이의 간격을 10000으로 설정하여 사용한다.<br>자세히 알필요는 없지만 추후에 방화벽 설정에 유의해야한다.</p>
<h2 id="Redis-x-Docker"><a href="#Redis-x-Docker" class="headerlink" title="Redis x Docker"></a>Redis x Docker</h2><p>Redis Cluster공식 튜토리얼을 읽어보면 Redis는 Docker의 bridge, 혹은 overlay네트워크를 지원하지 않는다고 작성되어있다. 그래서 기본적으로 Host모드를 사용하라고 한다. 작성하면서 다른글들을 좀 읽어보았는데 Redis 4.0 이상의 버전부터는 <code>cluster-announce-ip</code>, <code>cluster-announce-port</code>, <code>cluster-announce-bus-port</code>를 직접지정할 수 있게되어서 다른 네트워크도 사용이 가능해진것 같다. 여기에 대해 자세한 사항은 아래글을 참고하도록 하자.<br><a href="https://get-reddie.com/blog/redis4-cluster-docker-compose/" rel="external nofollow noopener noreferrer" target="_blank">https://get-reddie.com/blog/redis4-cluster-docker-compose/</a><br>필자의 경우 Redis Instance를 Host Mode로 사용하고 있다.</p>
<h2 id="Try-Redis-Cluster"><a href="#Try-Redis-Cluster" class="headerlink" title="Try Redis Cluster"></a>Try Redis Cluster</h2><p>이제 간단하게 Redis Cluster를 구성해보자. 지금 만들어볼 구조는 Master 3, Slave 3개의 노드를 갖는 Redis Cluster이다.</p>
<h3 id="Redis를-설치한다"><a href="#Redis를-설치한다" class="headerlink" title="Redis를 설치한다."></a>Redis를 설치한다.</h3><p>Source를 받아서 컴파일하는 방식으로 설치할 수 있고, apt와 같은 패키지 매니저로 설치할 수 있다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-4.0.11.tar.gz</span><br><span class="line">tar -xvf redis-4.0.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-4.0.11</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<h3 id="Redis-Cluster에-사용될-Reids-Server를-셋팅한다"><a href="#Redis-Cluster에-사용될-Reids-Server를-셋팅한다" class="headerlink" title="Redis Cluster에 사용될 Reids Server를 셋팅한다."></a>Redis Cluster에 사용될 Reids Server를 셋팅한다.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir cluster-test</span><br><span class="line"><span class="built_in">cd</span> cluster-test</span><br><span class="line">mkdir $(seq 7000 7005)</span><br></pre></td></tr></table></figure>
<p>위와같이 cluster-test 라는 폴더를 만들고 거기에 서버에서 각각사용할 포트별로 폴더를 구성한다.<br>폴더에는 각서버의 config파일과 redis-server executable 파일이 들어가면 된다.<br>config 파일은 redis설치폴더에 그리고 redis-server파일은 src폴더 아래에 존재한다.<br>해당파일을 폴더에 각각 복사하도록 하자.</p>
<p>이때 redis.conf파일에 들어갈 내용은 cluster기본설정만을 포함하고 있다.<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line">dbfilename dump-cluster00.rdb</span><br><span class="line">cluster-config-file nodes.conf</span><br></pre></td></tr></table></figure></p>
<h3 id="Redis-Server를-실행한다"><a href="#Redis-Server를-실행한다" class="headerlink" title="Redis Server를 실행한다."></a>Redis Server를 실행한다.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 폴더 별로 들어가서 실행 (귀찮다면 bash script를 하나만들어서 쓰면 된다. )</span></span><br><span class="line">./redis-server ./redis.conf &amp;</span><br></pre></td></tr></table></figure>
<p>여기까지 되었다면 redis-cli 를 통해서 접속이 가능한 상태가 되었다.<br>하지만 아직 cluster로 구성해주지 않았기 때문에 get,set이 불가능하다.</p>
<p>cluster를 만드는 도구는 여러가지가 존재한다.</p>
<ul>
<li>redis-cli</li>
<li>redis-trib.rb</li>
<li>redis-trib.py</li>
</ul>
<p>이글에선 redis-trib.rb를 통해 만들어보도록 한다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb create --replicas 1 \</span><br><span class="line">        127.0.0.1:7000 \</span><br><span class="line">        127.0.0.1:7001 \</span><br><span class="line">        127.0.0.1:7002 \</span><br><span class="line">        127.0.0.1:7003 \</span><br><span class="line">        127.0.0.1:7004 \</span><br><span class="line">        127.0.0.1:7005</span><br></pre></td></tr></table></figure></p>
<p>replicas 1은 master하나당 slave하나라는 의미이다.<br>위 명령어를 실행하면 위에서 부터 3개의 master 그밑으로 3개의 slave로 설정할거냐고 묻는 메시지가 나온다.<br>yes를 누르면 cluster가 구성된다.</p>
<h3 id="접속해서-Test-한다"><a href="#접속해서-Test-한다" class="headerlink" title="접속해서 Test 한다."></a>접속해서 Test 한다.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 -c</span><br></pre></td></tr></table></figure>
<p>뒤에 <code>-c</code>옵션은 cluster mode를 의미하므로 반드시 붙여주어야 한다.<br>접속이 정상적으로 이루여젔다면 get, set 명령어를 통해서 dataset의 분산저장 그리고 failover테스트를 할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> &lt;KEY&gt; &lt;VALUE&gt;</span><br><span class="line">get &lt;KEY&gt;</span><br></pre></td></tr></table></figure>
<p>set이나 get을 실행하면 어떤 cluster node로 Redirect됬는지 간단하게 나올것이다.<br>그리고 Failover 테스트의 경우 server를 하나씩 내리면서 테스트하면 된다. 필자의 경우 8개의 노드중 6개이상 Down되지않으면 정상적으로 동작하였다.</p>
<h2 id="유의사항"><a href="#유의사항" class="headerlink" title="유의사항"></a>유의사항</h2><p>Redis Cluster를 사용할땐 Client가 cluster를 지원해야 한다. 필자는 spring환경에서 Jedis Client를 활용하였다.<br>Spring Boot은 간단하게 되어있는데 MVC는 오래되서 마땅한 예제를 찾기 어려웠던 기억이 있다.</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>간단하게 Redis Cluster를 구축해보고 적용해보았는데 구축자체는 굉장히 간단하지만 여러가지로 생각을 많이 해봤던것같다. Sentinel과 Cluster 사이에서 어떤것을 사용할지 고민했었고 한편으론 Redis의 용도에 비해 과한 아키텍쳐가 아닌가 까지생각을 해봤던것같다. 처음 Redis를 도입하게된 이유도 Session Clustering이나 Cache를 현재 구조에서 가장 적절하게 풀어낼 수 있을거라 생각했는데 관리포인트가 느는건 어쩔수 없는느낌이다. Redis는 Socket, Cache, session등 정말 여러가지 용도로 사용되고 있지만 좀 더 잘 활용할수 있는 밥법도 생각해봐야겠다.</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://redis.io/topics/cluster-tutorial" rel="external nofollow noopener noreferrer" target="_blank">Redis-tutorial</a></li>
<li><a href="https://get-reddie.com/blog/redis4-cluster-docker-compose/" rel="external nofollow noopener noreferrer" target="_blank">Redis 4 with docker-compose</a></li>
</ul>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/Redis/">Redis</a></div><div class="article__author" itemscope="" itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.jpg" alt="HoSung"><a class="article__author__link" title="About HoSung" rel="author">HoSung</a><p class="article__author__desc">Web Developer &amp; Student</p><div class="article__author__socials"><a class="article__author__socials__item" href="http://github.com/y0c" title="github" target="_blank" rel="external nofollow noopener noreferrer"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="HoSung"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//lazy-developer.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-10-23T06:50:10.119Z"><meta itemprop="articleBody" content="최근에 구축한 서버환경 중 Session Clustering과 Cache의 용도로 Redis를 사용한 적이 있다.하지만 Redis가 설치된 서버가 한개라 해당 서버가 다운되면 모든 WAS가 서비스를 하지못하는 상황이 나오게 된다.이런 문제때문에 FailOver처리를 위해 Redis Cluster 구축을 생각하게 되었다.이번 포스팅에선 Redis..."><meta itemprop="url" content="https://y0c.github.io/2018/10/21/redis-cluster/"><meta itemprop="mainEntityOfPage" content="https://y0c.github.io/2018/10/21/redis-cluster/"><div itemscope="" itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="Lazy Developer"><div itemscope="" itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://y0c.github.io/images/logo.svg"></div></div><div itemscope="" itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="https://y0c.github.io/images/redis.png"><meta itemprop="url" content="https://y0c.github.io/images/redis.png"><meta itemprop="width"><meta itemprop="height"></div></article></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2018/10/22/jenkins-docker-tomcat/">Jenkins x Docker Tomcat War 배포하기</a></li><li class="recent-posts__item"><a href="/2018/10/21/redis-cluster/">Redis Cluster 구축하기</a></li><li class="recent-posts__item"><a href="/2018/10/20/Docker-Private-Registry/">Docker Private Registry 구축하기</a></li><li class="recent-posts__item"><a href="/2018/09/28/centos7-mail-server/">CentOS 7 Mail Server 구축하기 Postfix + Dovecot</a></li><li class="recent-posts__item"><a href="/2018/09/27/tmux-tutorial/">Tmux Tutorial 정리</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Archives</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">2</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tmux/">Tmux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/serverless/">serverless</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2018 HoSung<br>Powered by <a href="https://hexo.io" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external nofollow noopener noreferrer" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>