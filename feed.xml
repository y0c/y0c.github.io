<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lazy Developer</title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://y0c.github.io/"/>
  <updated>2018-09-09T13:34:18.192Z</updated>
  <id>https://y0c.github.io/</id>
  
  <author>
    <name>HoSung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS의 Generator와 Iterator</title>
    <link href="https://y0c.github.io/2018/09/09/js-generator/"/>
    <id>https://y0c.github.io/2018/09/09/js-generator/</id>
    <published>2018-09-09T08:43:24.000Z</published>
    <updated>2018-09-09T13:34:18.192Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/js.png"/><h1 id="ES6의-Generator와-Iterator"><a href="#ES6의-Generator와-Iterator" class="headerlink" title="ES6의 Generator와 Iterator"></a>ES6의 Generator와 Iterator</h1><p>이번 포스팅에선 ES6의 Generator와 Iterable, Iterator에 대해서 다뤄보려고 한다. Generator를 살펴보기 전에 먼저 Iterable과 Iterator에 대해서 이해하고 넘어가도록 하자. </p><p>사실 요즘 왠만한 언어들은 반복(loop)에 대해서 추상화된 방법과 인터페이스를 제공하고 있다. Java를 예로들면 Iterator라는 인터페이스를 제공하고 있다.  이런식의 반복(loop)을 추상화된 인터페이스로 제공할경우 얻을 수 있는 장점은 내장반복이 있는 <code>Array</code>나 <code>Map</code> 과 다르게 사용자 정의 Object나 기본 반복동작이 없는 객체들도 <code>for...of</code> 문으로 동일하게 반복을 정의할 수 있다는 것이다. </p><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>iterator 인터페이스는 반복에 대한 표준화된 방법을 제공한다.<br>구현 방법은 아래와 같다. </p><ul><li><code>next()</code>  메소드를 구현</li><li><code>next()</code> 메소드는 <code>IteratorResultObject</code>를 리턴</li></ul><h3 id="IteratorResultObject"><a href="#IteratorResultObject" class="headerlink" title="IteratorResultObject"></a>IteratorResultObject</h3><blockquote><p><code>done</code>  과 <code>value</code>를 갖는 객체.<br>여기서 <code>done</code>은 반복의 완료여부 <code>value</code>는 현재 값을 의미</p></blockquote><p>아래 예시는 배열을 인자로 받아서 반복하는 iterator 예시이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iter 함수는 iterator object를 리턴 </span></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;</span><br><span class="line">data,</span><br><span class="line">next() &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">done: <span class="keyword">this</span>.data.length == <span class="number">0</span>,</span><br><span class="line">value: <span class="keyword">this</span>.data.pop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayIterator = iterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrayIterator.next().value) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayIterator.next().value) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayIterator.next().value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p><code>Iterator</code>  만으로는 <code>for…of</code> 구문을 사용할 수 없다.<br>직접 반복에 대한 처리기를 구현해서 사용하거나 추가적으로 <code>Iterable</code>과 같이 사용하여야 한다. </p><h2 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h2><p>iterable 인터페이스를 구현하면 반복이 가능한 객체를 의미한다.<br>즉, 이 iterable 인터페이스를 구현하면 <code>for...of</code> 문을 통해 반복문을 작성할 수 있게된다.<br>인터페이스 구현은 단지  <code>Symbol.iterator</code>메소드를 만들어주면 된다. 단, 여기서 <code>Symbol.iterator</code> 메소드는 반드시 <code>iterator object</code>를 반환해야 한다. </p><p>아래 예시를 보고 좀 더 정확히 이해하도록 하자.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iter = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">//key는 @@iterator로 대체가 가능하다. </span></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">    <span class="comment">// iterator object를 반환 </span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data,</span><br><span class="line">      next() &#123; </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          done: <span class="keyword">this</span>.data.length == <span class="number">0</span>,</span><br><span class="line">          value: <span class="keyword">this</span>.data.pop()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> a <span class="keyword">of</span> iter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) </span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></p><p>위 <code>iterator</code>예제에 추가적으로 <code>iterable</code> 인터페이스를 구현하였다. 이 결과로 내장 반복처리기의 사용이 가능해진다. </p><p>내장반복처리기</p><ul><li>Array destructuring</li><li>Spread</li><li>Rest Parameter</li><li>For…of</li></ul><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>generator는 일반적으로 iterator를 쉽게 구현하기 위해 나온 문법으로 알고있다. 하지만 ES6의 generator는 단지 iteraotr를 쉽게 만들어주는 역활만을 한다고 보기는 어렵다.</p><p>먼저 <code>코루틴</code> 이라는 개념에 대해 알아보도록 하자. </p><h3 id="코루틴"><a href="#코루틴" class="headerlink" title="코루틴"></a>코루틴</h3><blockquote><p>일반적인 함수(루틴)은  Main Flow로 부터 단순히 값을 인자로 받아서 return으로 종료된다.<br> 여기에 return 과 더불어 <em>suspend/resume</em> 기능을 실행할 수 있게해준다.<br> 즉 중단을 걸고 중단된 지점부터 실행을 이어갈 수 있다. </p></blockquote><p><code>generator</code> 문법은 <code>iterator</code>를 통해서 이러한 코루틴을 만들어주는 역활을 한다. </p><ul><li><code>yield</code>키워드를 통해서 <code>suspend</code>를 걸 수 있다. </li><li><code>next()</code>가 호출되면  <code>resume</code>된다. </li></ul><p>위에서 만들었던 예제를 generator로 바꾸면 아래와같이 변경할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iter = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;</span><br><span class="line"><span class="comment">//key는 @@iterator로 대체가 가능하다. </span></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="keyword">let</span> v;</span><br><span class="line">        <span class="keyword">while</span>(v=data.pop()) <span class="keyword">yield</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> a <span class="keyword">of</span> iter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) </span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></p><p><code>iterator</code> 를 직접 구현했을 때보다 훨씬 간결하고 편리하게 작성할 수 있다. </p><p>이러한 <code>generator</code> 의 사용은 <code>iterator</code> 인터페이스의 구현을 도와주기도 하지만 비동기 코드를 다룰때 매우 유용히 사용할 수 있다. </p><p>아래 예시를 보도록 하자<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">    <span class="keyword">new</span> User(<span class="string">'tony'</span>,<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">new</span> User(<span class="string">'john'</span>,<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">new</span> User(<span class="string">'jang'</span>,<span class="number">30</span>)</span><br><span class="line">]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findUser = <span class="function"><span class="params">name</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(users.find(<span class="function"><span class="params">v</span> =&gt;</span> v.name == name));  </span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> submit = <span class="function"><span class="params">user</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(&#123; <span class="attr">success</span> : <span class="literal">true</span> &#125;);</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">yield</span> findUser(<span class="string">'tony'</span>);</span><br><span class="line">    user.name = <span class="string">'test'</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> submit(user);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>일반적으로 회원을 찾아서 수정한 후 submit하는 코드이다.<br>db를 따로 구현하지 않고 <code>setTimeout</code> 과 <code>Promise</code> 를 통해<br>Fake API를 만들었다. </p><p>generator를 사용하면 위 예제의 generator 함수와 같이 비동기적인 코드를 동기식으로 표현할 수 있게된다.<br>단, promise를 처리하는 반복처리기를 직접 구현해야한다. </p><p>처리기의 내용은 다음과 같다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseIterator = <span class="function"><span class="keyword">function</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> iterator = gen();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = iterator.next(arg);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( result.done ) &#123;</span><br><span class="line">            <span class="keyword">return</span> result.value;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(result.value).then(run);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 이처럼 사용이 가능하다. </span></span><br><span class="line">promiseIterator(generator())</span><br></pre></td></tr></table></figure></p><p>이 처리기는 간단하게 promise 반복처리기를 구현한 내용이다.<br>실제 사용은 <a href="https://github.com/tj/co" rel="external nofollow noopener noreferrer" target="_blank">Co</a> 와 같은 라이브러리를 사용해서 처리하도록 하자. </p><p>이러한 generator를 통한 비동기제어는 promise 처리기를 따로 구현하지 않아도 ES7의 async/await syntax를 통해서 좀 더 편리하게 사용할 수 있다. </p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" rel="external nofollow noopener noreferrer" target="_blank">Iteration protocols - JavaScript | MDN</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="external nofollow noopener noreferrer" target="_blank">반복기 및 생성기 - JavaScript | MDN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/js.png&quot;/&gt;&lt;h1 id=&quot;ES6의-Generator와-Iterator&quot;&gt;&lt;a href=&quot;#ES6의-Generator와-Iterator&quot; class=&quot;headerlink&quot; title=&quot;ES6의 Generator와 I
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript Decorator Pattern</title>
    <link href="https://y0c.github.io/2018/08/10/js-decorator/"/>
    <id>https://y0c.github.io/2018/08/10/js-decorator/</id>
    <published>2018-08-10T13:43:13.000Z</published>
    <updated>2018-09-09T01:23:51.272Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/js.png"/><p>Decorator Pattern의 사전적 정의는 아래와 같다. </p><blockquote><p>주어진 상황 및 용도에 따라 어떤 객체에 특성 혹은 행동을 덧붙이는 패턴 </p></blockquote><p>서브클래싱 보다 좀 더 유연한 기능확장을 할 수 있도록 대안으로 쓰임<br>앞서 학습한 Builder Pattern에서는 원하는 속성만 셋팅해서 손쉽게 원하는 객체를 만들어냈다면 Decorator Pattern 을 사용한다면 <em>OCP 원칙</em>에 어긋나지 않게 객체를 원하는기능만 손쉽게 추가할때 용이하다. </p><p>먼저 일반적인 Decorator Pattern의 예제를 보자.<br>아래 예제는 Head First 책에서 나오는 예제를 조금 변형해서 Javascript로 작성한 것이다.<br>( 코드 가독성을 위해 <em>ES6 Syntax</em> 로 작성하였다.)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    getCost() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getIngredients() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Coffee"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeDecorator</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(decoraterCoffee) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.decoraterCoffee = decoraterCoffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getCost() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.decoraterCoffee.getCost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getIngredients() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.decoraterCoffee.getIngredients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Cost : <span class="subst">$&#123;<span class="keyword">this</span>.getCost()&#125;</span> , Ingredients : <span class="subst">$&#123;<span class="keyword">this</span>.getIngredients()&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">CoffeeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    getCost() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getCost() + <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getIngredients() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getIngredients() + <span class="string">", Milk"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cream</span> <span class="keyword">extends</span> <span class="title">CoffeeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    getCost() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getCost() + <span class="number">0.7</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getIngredients() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getIngredients() + <span class="string">", Cream"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> caffeLatte = <span class="keyword">new</span> Milk(coffee);</span><br><span class="line"><span class="keyword">let</span> caffeMocha = <span class="keyword">new</span> Cream(milkCoffee);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Inline-Style</span></span><br><span class="line"><span class="comment">// let milkCreamCoffee = new Cream( new Milk( new Coffee() ) );</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(caffeLatte.toString()); <span class="comment">// Print -&gt; Cost : 1.5 , Ingredients : Coffee, Milk</span></span><br><span class="line"><span class="built_in">console</span>.log(caffeMocha.toString()); <span class="comment">// Print -&gt; Cost : 2.2 , Ingredients : Coffee, Milk, Cream</span></span><br></pre></td></tr></table></figure><p>위 예제는 주어진 재료를 가지고 다양한 형태의 커피를 만드는 예제이다.<br>만약 클래스의 상속을 통해 위 기능을 구현하려 한다면 CaffeeLatte, CaffeeMocha 등<br>커피의 종류가 늘어날수록 클래스를 추가해주어야 할 것이다.  데코레이터 패턴을 적용한다면 위와같이 재료를 정의해놓고 커피를 만들때 필요한 것들만 유연하게 추가하여   커피를 제조할 수 있게된다. </p><h3 id="Javascript-에서의-Decorator-Pattern"><a href="#Javascript-에서의-Decorator-Pattern" class="headerlink" title="Javascript 에서의 Decorator Pattern"></a>Javascript 에서의 Decorator Pattern</h3><p>자바스크립트는 함수형 프로그래밍이 가능하기 때문에 고차 함수(Higher-Order Function)을 통한 Decorator 구현이 가능하다. 실제로 많은 라이브러리나 프레임워크에서도 이와같은 패턴으로 많이 사용되고 있다. </p><p>예를 들자면 최근에  React의 Higher Order Component나<br>물론 Express의 Middleware 같은 경우 Decorator Pattern 과 Chain-Of-Responsibility 가 조합된 형태이다. </p><h3 id="Higher-Order-Function-을-이용한-Decoractor-예제"><a href="#Higher-Order-Function-을-이용한-Decoractor-예제" class="headerlink" title="Higher-Order Function 을 이용한 Decoractor 예제"></a>Higher-Order Function 을 이용한 Decoractor 예제</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxRequest</span>(<span class="params">url, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`request -&gt; <span class="subst">$&#123;url&#125;</span> , <span class="subst">$&#123;method&#125;</span>, <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggerDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Start'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Argument : <span class="subst">$&#123;args.join(<span class="string">' , '</span>)&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">const</span> result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'End'</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = loggerDecorator(ajaxRequest);</span><br><span class="line"></span><br><span class="line">request(<span class="string">'http://www.naver.com'</span>, <span class="string">'get'</span>, <span class="string">'query=test'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="comment">//Start</span></span><br><span class="line"><span class="comment">//Argument : http://www.naver.com , get , query=test</span></span><br><span class="line"><span class="comment">//request -&gt; http://www.naver.com , get, query=test</span></span><br><span class="line"><span class="comment">//End</span></span><br></pre></td></tr></table></figure><p>위 예제처럼 ajaxRequset를 하는 함수에 logging을 해주는 decorator를 추가한 예제이다.  이 예제는 정말 간단한 예제이지만 매우 유용하게 사용될 수 있다.<br>전처리, 후처리 공통된 작업을 Decorator를 통해 추가할 수 있고  기능을 손쉽게 확장할 수 있다. </p><h3 id="ES7-Decorator"><a href="#ES7-Decorator" class="headerlink" title="ES7 Decorator"></a>ES7 Decorator</h3><p>ECMAScript2016(ES7) 스펙에 추가된 것 중 Decorator라는 문법이 새로 제안되었다.  이 Decorator 문법은<code>class</code>, <code>function</code>, <code>property</code> 모두 어떤 특성이나 행동을 쉽고 깔끔하게 덧붙일 수 있다.  위에서 고차함수를 통해 구현했던 Decorator를 ES7의 Decorator 문법을 통해  아래와 같이 변경해 볼 수 있다.<br>(아래 예제는 log 이외에 권한체크를 하는 decorator를 추가로 구현했다)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//log Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> func = descriptor.value;</span><br><span class="line"></span><br><span class="line">        descriptor.value = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Start'</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Argument : <span class="subst">$&#123;args.join(<span class="string">' , '</span>)&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">const</span> result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Fake Auth</span></span><br><span class="line"><span class="keyword">const</span> AuthUtil = &#123;</span><br><span class="line">    isAuth: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    roleCheck: <span class="function">(<span class="params">role</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> currentUserRole = <span class="string">'admin'</span>;</span><br><span class="line">        <span class="keyword">return</span> role === currentUserRole;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Authentication Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Authentication</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    isAuth,</span></span></span><br><span class="line"><span class="function"><span class="params">    role</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">target, name, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> func = descriptor.value;</span><br><span class="line"></span><br><span class="line">        descriptor.value = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isAuth) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!AuthUtil.isAuth()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unauthorized Error!!!'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (role) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!AuthUtil.roleCheck(role)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unauthorized Error!!!'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @log(<span class="string">'index page'</span>)</span><br><span class="line">    index() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'request -&gt; index'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @log(<span class="string">'login page'</span>)</span><br><span class="line">    login() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'request -&gt; login'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @log(<span class="string">'admin page'</span>)</span><br><span class="line">    @Authentication(&#123;</span><br><span class="line">        isAuth: <span class="literal">true</span>,</span><br><span class="line">        role: <span class="string">'admin'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    admin() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'request -&gt; admin'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    router.index(<span class="string">'test'</span>, <span class="string">'test2'</span>);</span><br><span class="line">    router.admin(<span class="string">'request admin page...'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Start</span></span><br><span class="line"><span class="comment">Argument : test , test2</span></span><br><span class="line"><span class="comment">request -&gt; index</span></span><br><span class="line"><span class="comment">test</span></span><br><span class="line"><span class="comment">Start</span></span><br><span class="line"><span class="comment">Argument : request admin page...</span></span><br><span class="line"><span class="comment">Unauthorized Error!!!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>이 글에선 ES7 Decorator에 대해 자세히 내용을 다루진 않는다.<br>( 파라미터에 대한 설명등은 babel 이나 mdn을 참조하도록 하자)</p><p>Decorator 자체는 함수이고 이 함수는 원래 함수를 변형시켜 새로운 함수를 만들어서 리턴한다. 아마 위에 Decorator Pattern에 대해 이해했다면 어렵지 않게 이해할 수 있을거라고 생각한다. </p><p>위 예제와 같이 logging, auth check, parameter check 등 공통적으로 분리하기 어려운 관심사(Cross-Cutting Concern) 을 깔끔하게 분리해서 구현하고 사용할 수 있다. </p><p>최근 React에서도 HOC와 Decorator를 조합해서 위와 비슷한 패턴으로 많이 사용되고 있다고 한다. 추후에 이 조합에 대해서도 다뤄봐야 될 것 같다. </p><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p>ES7의 Decorator문법은 아직 제안 상태이므로 babel 과 함께 사용하여야 정상적으로 작동한다.  [링크]<a href="https://babeljs.io/docs/plugins/transform-decorators/" rel="external nofollow noopener noreferrer" target="_blank">Decorators transform · Babel</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/js.png&quot;/&gt;&lt;p&gt;Decorator Pattern의 사전적 정의는 아래와 같다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;주어진 상황 및 용도에 따라 어떤 객체에 특성 혹은 행동을 덧붙이는 패턴 &lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Serverless Koa기반 Api Server 배포하기</title>
    <link href="https://y0c.github.io/2018/07/29/serverless-koa/"/>
    <id>https://y0c.github.io/2018/07/29/serverless-koa/</id>
    <published>2018-07-28T15:37:00.000Z</published>
    <updated>2018-07-28T16:05:20.235Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/serverless.png"/><p>이 포스팅에선 aws lambda와 serverless framework를 통해서 koa 기반의 api server를 배포하는 것에 대해 소개하려한다.<br>전체적인 배포 과정을 나열하기보다는 간략한 소개와 boilerplate로 어떤식으로 접근하는지에 중점을 두었다. </p><p>필자가 처음 lambda를 접했을땐 토픽별 기능(크롤링, 이미지처리) 이나 AWS와 연계된 서비스에서 모니터링 혹은 알림 같은 곳에 사용할때 유용한 정도로만 생각하고 있었다.<br>lambda에서는 node.js, phtyon, java 등과 같은 여러가지 언어를 제공하고 있지만<br>실제로 api server를 통째로 lambda를 이용하기엔 오히려 불편한점이 꽤 많아 보였기 때문이다. </p><p>아래 코드는 AWS lambda 에서 제공하는  nodejs 예시 코드이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.myHandler = <span class="function"><span class="keyword">function</span>(<span class="params">event, context, callback</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"value1 = "</span> + event.key1);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"value2 = "</span> + event.key2);  </span><br><span class="line">   callback(<span class="literal">null</span>, <span class="string">"some success message"</span>);</span><br><span class="line">   <span class="comment">// or </span></span><br><span class="line">   <span class="comment">// callback("some error type"); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 코드가 하나의 function 즉 endpoint가 된다.<br>단순한 하나의 function 이 아닌 api server를 개발하려면 수 많은 lambda function을 만들어야하기 떄문에 구조가 굉장히 난해해 보였다. </p><p>지금껏 express, koa, hapi 와 같은 프레임워크를 통해 backend 개발을 해왔다면  위구조에서 어떤식으로 사용해야될지 잘 감이 오지 않을것이다. </p><p>최근에 지인을 통해 serverless-http 모듈에 대해 듣고 잠시 접해볼기회가 있었는데<br>serverless-http는 lambda에 대한 약간의 이해만 있으면 기존에 express나 koa를 통해서 API를 쉽게 Wrap해서 배포할 수 있게된다.<br>실제로 사용해본 경험으론 serverless-http를 사용하게되면 간단한 설치와 몇라인으로 wrapping 할 수 있었다.<br>모듈에대한 자세한 설명은 해당 Repo를 참고하도록 하자.<br><a href="https://github.com/dougmoscrop/serverless-http" rel="external nofollow noopener noreferrer" target="_blank">GitHub - dougmoscrop/serverless-http: Use your existing middleware framework (e.g. Express, Koa) in AWS Lambda 🎉</a></p><p>이제 본격적으로  koa 기반 api-server 를 lambda에 배포하는 작업을 해보자.<br>이 작업을 하기위해선 AWS계정과 Serverless 계정이 필요하다.<br><a href="https://serverless.com/" rel="external nofollow noopener noreferrer" target="_blank">Serverless - The Serverless Application Framework powered by AWS Lambda, API Gateway, and more</a><br><a href="https://aws.amazon.com/ko/" rel="external nofollow noopener noreferrer" target="_blank">https://aws.amazon.com/ko/</a></p><p>AWS는 계정을 만든후  IAM을 통해 user를 만든후 <code>access_key</code> 와 <code>secret_key</code>가 필요하다. 이 과정에 대해선 아래 글에 자세히 설명되있으니 참조하도록 하자.<br><a href="https://github.com/serverless/serverless/blob/master/docs/providers/aws/guide/credentials.md" rel="external nofollow noopener noreferrer" target="_blank">serverless/credentials.md at master · serverless/serverless · GitHub</a></p><p>먼저, serverless 를 설치한다.<br><code>npm install -g serverless</code></p><p>아래 명령어는 aws nodejs용 템플릿을 만들어주는데 틀을 보고 필요한 부분은 찾아서 작성하도록한다.<br><code>serverless create -t aws-nodejs</code> </p><p>koa기반 app 을 배포할것이기 때문에 serverless-http 모듈도 설치하도록 하자.<br><code>npm install serverless-http</code> </p><p>여기까지 됬다면  기본적인 앱을 배포하는데 기본적인 준비가 끝난 것이다.<br>기존 koa app을 개발하는 구조와 동일하게 사용하여도 무방하다.<br>serverless 배포를 위해 작성해야될 코드는 아래가 전부이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> serverless <span class="keyword">from</span> <span class="string">'serverless-http'</span>;</span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">'app'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler는 serverless yml 파일에서 지정해준 이름을 사용하여야한다. </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> handler = serverless(app);</span><br></pre></td></tr></table></figure></p><p>app을 배포할때는 <code>sls deploy —stage &lt;stage_name&gt;</code> 을 통해서 배포할 수 있다. </p><p>사용해본 후기로 생각보다 간단하게 koa 혹은 express app을 lambda로 배포할 수 있었다. 앞으로도 간단한 api server 를 구성할때 자주 사용하게 될 것 같다. </p><p>express 기반 boilerplate는 검색하면 바로나오는 편인데 koa 관련해서는 boilerplate가 적당한게 보이지않아서 연습하면서 간단하게 boilerplate를 구성해보았다.  </p><p><a href="https://github.com/y0c/serverless-koa-boilerplate" rel="external nofollow noopener noreferrer" target="_blank">GitHub - y0c/serverless-koa-boilerplate: Serverless-http with Koa Boilerplate</a></p><p>ES6/7 Syntax를 사용할 수 있도록 babel 과 serverless-webpack 관련 설정을 추가된 boilerplate 이다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/serverless.png&quot;/&gt;&lt;p&gt;이 포스팅에선 aws lambda와 serverless framework를 통해서 koa 기반의 api server를 배포하는 것에 대해 소개하려한다.&lt;br&gt;전체적인 배포 과정을 나열
      
    
    </summary>
    
      <category term="serverless" scheme="https://y0c.github.io/categories/serverless/"/>
    
    
      <category term="serverless" scheme="https://y0c.github.io/tags/serverless/"/>
    
      <category term="serverless-http" scheme="https://y0c.github.io/tags/serverless-http/"/>
    
      <category term="koa" scheme="https://y0c.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>React Component 생명주기</title>
    <link href="https://y0c.github.io/2018/01/06/React-Component-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/"/>
    <id>https://y0c.github.io/2018/01/06/React-Component-생명주기/</id>
    <published>2018-01-05T23:53:57.000Z</published>
    <updated>2018-01-05T23:59:05.874Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/react.jpg"/><hr><h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><ol><li><a href="#mounting">Component LifeCycle - Mounting</a></li><li><a href="#updating">Component LifeCycle - Updating</a></li><li><a href="#unmounting">Component LifeCycle - Unmounting</a></li></ol><hr><p>Web Service, Mobile App 또는 다른 Application을 개발해봤다면 <code>생명주기</code> 라는말을 한 번쯤 들어보았을 것이다.  혹시 들어보지 못했더라도 전혀 상관없다!<br>생명주기란 Application 이 시작, 실행, 활성, 비활성, 정지, 종료 등 일련의 상태를 순환하는데 이것을 생명주기라고 한다.</p><p>React 에서도 마찬가지로 Component가 <code>생성</code>, <code>수정</code>, <code>소멸</code> 크게 3가지 부분으로 나뉘어서  LifeCycle API 가 제공되고 있는데. 이것들을 기억해두셨다가 개발도중에 필요할때 적절하게 구현해놓고 사용하면 된다.</p><div id="mounting"><br></div><h2 id="Component-LifeCycle-Mounting"><a href="#Component-LifeCycle-Mounting" class="headerlink" title="Component LifeCycle - Mounting"></a>Component LifeCycle - Mounting</h2><img src="/2018/01/06/React-Component-생명주기/mounting.png" title="React LifeCycle Mounting"><p>컴포넌트가 생성될때 호출되는 LifeCycle API 이다.<br>생성자 메소드의 경우 ES6를 사용하지 않는다면 <code>getInitialState</code> 메소드를 사용하실 수 있고 더 자세한 내용은 React 공식문서 <a href="https://reactjs.org/docs/react-without-es6.html" rel="external nofollow noopener noreferrer" target="_blank">React Without ES6</a> 를 참고하도록 하자.</p><div id="updating"><br></div><h2 id="Component-LifeCycle-Updating"><a href="#Component-LifeCycle-Updating" class="headerlink" title="Component LifeCycle - Updating"></a>Component LifeCycle - Updating</h2><img src="/2018/01/06/React-Component-생명주기/updating.png" title="React LifeCycle Updating"><p>컴포넌트가 생성될때 호출되는 LifeCycle API 이다.<br>여기서 <em>shouldComponentUpdate</em> 메소드는 중요한 역활을 한다.<br><strong>이 메소드에서 변경된 props와 state를 통해 리렌더링을 할지 여부를 결정하게 되는데 기본적으로 true를 리턴하게 되있는데 false를 리턴할경우 렌더링을 하지 않는다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate( nextProps, nextState ) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextProps.list !== <span class="keyword">this</span>.props.list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 shouldComponentUpdate를 통해 이전 props와 변경될 props를 비교해서 렌더링 여부를 결정하는 예시이다. 여기서 기억해두어야할 점은 React에서는<br><code>deep checking</code>이나 <code>JSON.stringfiy()</code> 메소드를 통한 비교는 권장하지 않는다는 것이다.<br>이는 비효율적이고 성능에 영향을 끼치기 때문에 일반적으로 <code>shallow checking</code>을 사용하고 있다. <code>deep checking</code> , <code>shallow checking</code>, <code>immutable fashion</code> 에 관해서는 다른 글을 통해서 더 자세히 다뤄볼 수 있도록 준비할 예정이다.</p><p><code>React.PureComponent</code>를 상속받게되면 props와 state에 대해 shallow compare로직이 들어가 있어서 좀 더 편리하게 사용할 수 있다고 한다.<br>하지만 무분별하게 PureComponent를 상속받아서 사용한다면 오히려 성능저하를 야기할 수 있고 적절히 필요한곳에 shouldComponentUpdate를 구현하여 사용하시는 것이 좋은 방법이라고 생각된다.</p><p>그리고 설사 shouldComponentUpdate를 구현하지 않아서 무조건 true를 리턴하는 상황이 있다고 하더라도 React는 모든경우에 리렌더링을 하지는 않는다. shouldComponentUpdate를 통해 true를 리턴하게 되면 기존 Vitural DOM과 변경된 props나 state를 통해 만들어질 Vitural DOM과 비교하여 변경된 내용이 없다면 리렌더링을 하지 않는다.</p><p>하지만 규모가 커질수록 큰 성능 차이를 낼 수 있기 때문에 최적화 하는 습관을 들여놓는게 좋다고 생각한다.</p><div id="unmounting"><br></div><h2 id="Component-LifeCycle-Unmounting"><a href="#Component-LifeCycle-Unmounting" class="headerlink" title="Component LifeCycle - Unmounting"></a>Component LifeCycle - Unmounting</h2><img src="/2018/01/06/React-Component-생명주기/unmounting.png" title="React LifeCycle Unmounting"><p>컴포넌트가 소멸될시 호출되는 LifeCycle API입니다.<br>위 설명과 같이 타이머 제거, 네트워크 요청취소, 이벤트 리스너 제거등에 주로 사용된다.</p><h3 id="개인-공부용으로-쓴-글이라-혹시-잘못된-정보가-있다면-댓글로-알려주시면-수정하도록하겠습니다"><a href="#개인-공부용으로-쓴-글이라-혹시-잘못된-정보가-있다면-댓글로-알려주시면-수정하도록하겠습니다" class="headerlink" title="개인 공부용으로 쓴 글이라 혹시 잘못된 정보가 있다면 댓글로 알려주시면 수정하도록하겠습니다."></a>개인 공부용으로 쓴 글이라 혹시 잘못된 정보가 있다면 댓글로 알려주시면 수정하도록하겠습니다.</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/react.jpg&quot;/&gt;&lt;hr&gt;
&lt;h1 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#mounting&quot;&gt;Component
      
    
    </summary>
    
      <category term="React" scheme="https://y0c.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://y0c.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Event Handling</title>
    <link href="https://y0c.github.io/2018/01/03/React-Event-Handling/"/>
    <id>https://y0c.github.io/2018/01/03/React-Event-Handling/</id>
    <published>2018-01-03T14:30:05.000Z</published>
    <updated>2018-01-05T23:59:05.878Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/react.jpg"/><hr><h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><ol><li><a href="#react-dom-difference">React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이</a></li><li><a href="#react-event-bind-method">React에서 Event를 바인딩하는 여러가지 방법</a></li><li><a href="#react-synthetic-event">SyntheticEvent</a></li></ol><hr><div id="react-dom-difference"><br></div><h2 id="React-와-일반적인-DOM-element-에서-이벤트-핸들링의-차이"><a href="#React-와-일반적인-DOM-element-에서-이벤트-핸들링의-차이" class="headerlink" title="React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이"></a>React 와 일반적인  DOM element 에서 이벤트 핸들링의 차이</h2><p>React에서 이벤트를 핸들링하는 방법은 DOM elements의 이벤트를 핸들링 하는 방법과 매우 유사하다.  아래 가장 기본적인 예시를 보도록 하자.<br>먼저 일반적인 <code>DOM Element</code>의 바인딩 하는 방법이다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"activeLasers()"</span>&gt;</span></span><br><span class="line">Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>위와 같이 표현할 수 있다.</p><p>같은 역활을 하는 Element를 <code>React Way</code>로 표현하면 다음과 같다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.activeLaser&#125;</span>&gt;</span></span><br><span class="line">Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>첫 번째 차이점은 React에서는 Event를 <em>CamelCase</em>를 사용하여 표기한다는 점이다.<br>두번째로 일반적인 DOM에서 이벤트를 바인딩 할 때에는 function을 직접 호출하지만 React는 이벤트를 직접 호출하지않고 function을 지정해주기만 한다.<br>(즉 function 의 포인터 만 넘겨주고 직접 핸들링하지 않는다.)</p><h3 id="return-false-에-관해"><a href="#return-false-에-관해" class="headerlink" title="return false; 에 관해"></a>return false; 에 관해</h3><p>DOM element에 이벤트를 바인딩 한 경험이 있다면 <code>return false;</code> 를 많이 사용해봤을 것이다. 이 <code>return false;</code>의 역활은 브라우저의 기본동작을 막아주도록 동작한다.<br>즉 <code>event.preventDefault</code>와 같은 역활을 한다고 볼 수 있다.</p><p>같은 syntax 를 jQuery event handler 안에서 사용할 경우<br><code>event.preventdefault()</code> 와 <code>event.stopPropagation()</code>을 동시에 처리해준다.</p><p><strong>하지만 React의 경우 return false와 같은 syntax는 아무 동작을 하지 않는다.</strong><br>반드시 기본동작이나 버블링을 제어할 시에는 명시적으로 <code>event.preventDefault()</code><br><code>event.stopPropagation()</code>을 작성해주어야 한다.</p><hr><div id="react-event-bind-method"><br></div><h2 id="React-에서-Event를-바인딩하는-여러가지-방법에-관하여"><a href="#React-에서-Event를-바인딩하는-여러가지-방법에-관하여" class="headerlink" title="React 에서 Event를 바인딩하는 여러가지 방법에 관하여"></a>React 에서 Event를 바인딩하는 여러가지 방법에 관하여</h2><p><strong>Event Handler 에서 this</strong><br>ES6 Class syntax를 사용하여 React Component를 작성한 경우 event handler에서 this는 undefined가 된다. 왜냐하면 javascript에서 this는 호출한 context에 의해 결정되기 때문이다.<br>만약 잘 이해가 가지 않는다면 아래 문서를 참고하도록 하자.</p><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this" rel="external nofollow noopener noreferrer" target="_blank">this - JavaScript | MDN</a></p><p>이러한 this 에 관한 이슈로 인해 this를 이벤트 핸들러가 아닌 클래스에 바인딩 할 수 있는 몇가지 방법을 소개해볼까한다.</p><p><strong>1. React.createClass</strong><br>React 의 createClass 메소드를 사용하여 컴포넌트를 제작할경우 react는 모든 함수를 this에 자동으로 바인딩한다.<br>즉 따로 바인딩 할 필요가 없지만 React.createClass syntax는 조만간 이후 버전의 릴리즈에서 추출 될 수 있으므로 지양하는 것이 좋다.</p><p><strong>2. Rendering 시 바인딩</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onChange=&#123;<span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>)&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같이 렌더링시에 바로 this에 바인딩 해주는 방법도 있는데 이는 렌더링이 실행될때마다 새로운 함수를 만들어주기 때문에 퍼포먼스에 좋지 않다고 한다.</p><p><strong>3. Constructor를 통한 바인딩</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>생성자 함수에서 함수를 바인딩해주는 방법이다. 생성자 호출 될시 한번만 바인딩 되므로 퍼포먼스 이슈가 없고 React에서 권장하는 가장 일반적인 방법인데<br>이벤트 핸들러가 많아지면 바인딩을 못한 휴먼에러가 생길 수 있고 매 번 바인딩을 하는 것은 꽤나 부담스럽고 귀찮은 작업이 될 수도 있다.</p><p><strong>4. Class Property 의 Arrow Function 을 통한 바인딩</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위와 같은 방법은 가장 심플하게 함수를 클래스에 바인딩 할 수 있는 방법을 제공하는데<br>해당 syntax를 사용하기 위해서는 babel <em>state-2</em> 혹은 <em>transfrom-class-properties</em> 가 추가되있어야 정상적으로 동작한다.</p><p><em>참고</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bork</span> </span>&#123;</span><br><span class="line">   <span class="comment">//Property initializer syntax</span></span><br><span class="line">   instanceProperty = <span class="string">"bork"</span>;</span><br><span class="line">   boundFunction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.instanceProperty;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Static class properties</span></span><br><span class="line">   <span class="keyword">static</span> staticProperty = <span class="string">"babelIsCool"</span>;</span><br><span class="line">   <span class="keyword">static</span> staticFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Bork.staticProperty;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> myBork = <span class="keyword">new</span> Bork;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Property initializers are not on the prototype.</span></span><br><span class="line"> <span class="built_in">console</span>.log(myBork.__proto__.boundFunction); <span class="comment">// &gt; undefined</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Bound functions are bound to the class instance.</span></span><br><span class="line"> <span class="built_in">console</span>.log(myBork.boundFunction.call(<span class="literal">undefined</span>)); <span class="comment">// &gt; "bork"</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Static function exists on the class.</span></span><br><span class="line"> <span class="built_in">console</span>.log(Bork.staticFunction()); <span class="comment">// &gt; "babelIsCool"</span></span><br></pre></td></tr></table></figure></p><p> 위 코드는 babel 공식문서에서 발췌한 코드이다.<br><a href="https://babeljs.io/docs/plugins/transform-class-properties/" rel="external nofollow noopener noreferrer" target="_blank">Class properties transform · Babel</a></p><p>코드에 있는 설명에는 Property initializer 를 통한 Arrow Function은 Prototype에 추가되지 않는다. 즉, Prototype 에 추가되지 않는 다는 의미는 클래스가 생성될때마다 메모리 공간을 차지하고 상속을 하지 못하는 문제점이 존재한다.</p><p>개인적인 생각으로는 이벤트 핸들러는 React Component 중에서도 주로 컨테이너 즉 Statefull Component 에 주로 바인딩 되고 props를 통해서 하위 컴포넌트로 핸들러를 전달한다. 컨테이너 특성상 자주 생성되지 않고 이벤트 핸들러는 일반적으로 상속이 자주 사용되지 않아서 단점보다 auto-binding을 통한 편리함과 장점이 크다고 생각하기 때문에 앞으로도 위와 같은 syntax를 자주 사용할 것 같다.<br>저런 방법 마저 마음에 들지 않는다면 <code>react-autobind</code>, <code>autobind-decorator</code> 와 같은 라이브러리들이 있으니 참고하도록 하자.</p><hr><div id="react-synthetic-event"><br></div><h2 id="SyntheticEvent"><a href="#SyntheticEvent" class="headerlink" title="SyntheticEvent"></a>SyntheticEvent</h2><p>React 에서는 DOM 이벤트를 직접다루지 않고 이를 Wrapping한 <code>SyntheticEvent</code>를 사용한다. 이 <code>SyntheticEvent</code> 를 사용함으로써 <strong>브라우저마다 다른 event 객체에 대해 신경쓸 필요가 없다!</strong> 즉 크로스 브라우징에 관한 이슈가 해결된다.<br>SyntheticEvent 에 관한 속성들은 따로 언급하진 않겠다.<br>DOM 이벤트와 완벽하게 매칭되는게 아니므로 찾아볼 게 있을때는 React 공식문서를 참조하도록 하자.<br><a href="https://reactjs.org/docs/events.html" rel="external nofollow noopener noreferrer" target="_blank">SyntheticEvent - React</a></p><hr><h3 id="개인-공부용으로-쓴-글이라-혹시-잘못된-정보가-있다면-댓글로-알려주시면-수정하도록하겠습니다"><a href="#개인-공부용으로-쓴-글이라-혹시-잘못된-정보가-있다면-댓글로-알려주시면-수정하도록하겠습니다" class="headerlink" title="개인 공부용으로 쓴 글이라 혹시 잘못된 정보가 있다면 댓글로 알려주시면 수정하도록하겠습니다."></a>개인 공부용으로 쓴 글이라 혹시 잘못된 정보가 있다면 댓글로 알려주시면 수정하도록하겠습니다.</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/react.jpg&quot;/&gt;&lt;hr&gt;
&lt;h1 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#react-dom-differenc
      
    
    </summary>
    
      <category term="React" scheme="https://y0c.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://y0c.github.io/tags/React/"/>
    
      <category term="Event Handling" scheme="https://y0c.github.io/tags/Event-Handling/"/>
    
  </entry>
  
</feed>
